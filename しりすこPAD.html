<!DOCTYPE html>
<!-- Updated: 2025-09-21 数字表記修正 -->
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>しりすこPAD</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        /* Google Material Design 3 (Material You) */
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            /* Material Design 3 Color System - Light Theme */
            /* Primary - Main brand color */
            --md-sys-color-primary: #6750A4;
            --md-sys-color-on-primary: #FFFFFF;
            --md-sys-color-primary-container: #EADDFF;
            --md-sys-color-on-primary-container: #21005D;

            /* Secondary - Accent color */
            --md-sys-color-secondary: #625B71;
            --md-sys-color-on-secondary: #FFFFFF;
            --md-sys-color-secondary-container: #E8DEF8;
            --md-sys-color-on-secondary-container: #1D192B;

            /* Tertiary - Additional accent */
            --md-sys-color-tertiary: #7D5260;
            --md-sys-color-on-tertiary: #FFFFFF;
            --md-sys-color-tertiary-container: #FFD8E4;
            --md-sys-color-on-tertiary-container: #31111D;

            /* Error */
            --md-sys-color-error: #B3261E;
            --md-sys-color-on-error: #FFFFFF;
            --md-sys-color-error-container: #F9DEDC;
            --md-sys-color-on-error-container: #410E0B;

            /* Background & Surface */
            --md-sys-color-background: #FFFBFE;
            --md-sys-color-on-background: #1C1B1F;
            --md-sys-color-surface: #FFFBFE;
            --md-sys-color-on-surface: #1C1B1F;
            --md-sys-color-surface-variant: #E7E0EC;
            --md-sys-color-on-surface-variant: #49454F;

            /* Outline */
            --md-sys-color-outline: #79747E;
            --md-sys-color-outline-variant: #CAC4D0;

            /* Surface Tints */
            --md-sys-color-surface-tint: #6750A4;
            --md-sys-color-inverse-surface: #313033;
            --md-sys-color-inverse-on-surface: #F4EFF4;
            --md-sys-color-inverse-primary: #D0BCFF;

            /* Shadows */
            --md-sys-color-shadow: #000000;
            --md-sys-color-scrim: #000000;

            /* Material Design 3 Typography Scale */
            /* Display - Largest text */
            --md-sys-typescale-display-large-font: 'Roboto', sans-serif;
            --md-sys-typescale-display-large-size: 57px;
            --md-sys-typescale-display-large-weight: 400;
            --md-sys-typescale-display-large-line-height: 64px;
            --md-sys-typescale-display-large-tracking: -0.25px;

            --md-sys-typescale-display-medium-size: 45px;
            --md-sys-typescale-display-medium-line-height: 52px;

            --md-sys-typescale-display-small-size: 36px;
            --md-sys-typescale-display-small-line-height: 44px;

            /* Headline */
            --md-sys-typescale-headline-large-size: 32px;
            --md-sys-typescale-headline-large-weight: 400;
            --md-sys-typescale-headline-large-line-height: 40px;

            --md-sys-typescale-headline-medium-size: 28px;
            --md-sys-typescale-headline-medium-line-height: 36px;

            --md-sys-typescale-headline-small-size: 24px;
            --md-sys-typescale-headline-small-line-height: 32px;

            /* Title */
            --md-sys-typescale-title-large-size: 22px;
            --md-sys-typescale-title-large-weight: 400;
            --md-sys-typescale-title-large-line-height: 28px;

            --md-sys-typescale-title-medium-size: 16px;
            --md-sys-typescale-title-medium-weight: 500;
            --md-sys-typescale-title-medium-line-height: 24px;
            --md-sys-typescale-title-medium-tracking: 0.15px;

            --md-sys-typescale-title-small-size: 14px;
            --md-sys-typescale-title-small-weight: 500;
            --md-sys-typescale-title-small-line-height: 20px;
            --md-sys-typescale-title-small-tracking: 0.1px;

            /* Body */
            --md-sys-typescale-body-large-size: 16px;
            --md-sys-typescale-body-large-weight: 400;
            --md-sys-typescale-body-large-line-height: 24px;
            --md-sys-typescale-body-large-tracking: 0.5px;

            --md-sys-typescale-body-medium-size: 14px;
            --md-sys-typescale-body-medium-weight: 400;
            --md-sys-typescale-body-medium-line-height: 20px;
            --md-sys-typescale-body-medium-tracking: 0.25px;

            --md-sys-typescale-body-small-size: 12px;
            --md-sys-typescale-body-small-weight: 400;
            --md-sys-typescale-body-small-line-height: 16px;
            --md-sys-typescale-body-small-tracking: 0.4px;

            /* Label */
            --md-sys-typescale-label-large-size: 14px;
            --md-sys-typescale-label-large-weight: 500;
            --md-sys-typescale-label-large-line-height: 20px;
            --md-sys-typescale-label-large-tracking: 0.1px;

            --md-sys-typescale-label-medium-size: 12px;
            --md-sys-typescale-label-medium-weight: 500;
            --md-sys-typescale-label-medium-line-height: 16px;
            --md-sys-typescale-label-medium-tracking: 0.5px;

            --md-sys-typescale-label-small-size: 11px;
            --md-sys-typescale-label-small-weight: 500;
            --md-sys-typescale-label-small-line-height: 16px;
            --md-sys-typescale-label-small-tracking: 0.5px;

            /* Legacy aliases for compatibility */
            --background: #FFFBFE;
            --background-secondary: #E7E0EC;
            --background-tertiary: #CAC4D0;
            --text-primary: #1C1B1F;
            --text-secondary: #49454F;
            --text-muted: #79747E;
            --primary-color: #6750A4;
            --secondary-color: #625B71;
            --accent-color: #7D5260;
            --success-color: #34C759;
            --warning-color: #FF9500;
            --accent-blue: #6750A4;
            --accent-green: #34C759;
            --accent-red: #B3261E;
            --accent-orange: #FF9500;
            --bg-primary: #FFFBFE;
            --bg-secondary: #E7E0EC;
            --bg-card: #FFFBFE;
            --bg-highlight: #E7E0EC;
            --bg-accent: #EADDFF;
            --border: #79747E;
            --border-color: #79747E;
            --border-hover: #49454F;
            --border-strong: #1C1B1F;
            --shadow: rgba(0, 0, 0, 0.3);
            --shadow-sm: 0px 1px 2px 0px rgba(0, 0, 0, 0.3), 0px 1px 3px 1px rgba(0, 0, 0, 0.15);
            --shadow-md: 0px 1px 2px 0px rgba(0, 0, 0, 0.3), 0px 2px 6px 2px rgba(0, 0, 0, 0.15);
            --shadow-lg: 0px 1px 3px 0px rgba(0, 0, 0, 0.3), 0px 4px 8px 3px rgba(0, 0, 0, 0.15);
            --chart-bg: #FFFBFE;
            --chart-grid: #E7E0EC;
            --chart-text: #1C1B1F;
        }

        /* Material Design 3 Dark Theme */
        [data-theme="dark"] {
            --md-sys-color-primary: #D0BCFF;
            --md-sys-color-on-primary: #381E72;
            --md-sys-color-primary-container: #4F378B;
            --md-sys-color-on-primary-container: #EADDFF;

            --md-sys-color-secondary: #CCC2DC;
            --md-sys-color-on-secondary: #332D41;
            --md-sys-color-secondary-container: #4A4458;
            --md-sys-color-on-secondary-container: #E8DEF8;

            --md-sys-color-tertiary: #EFB8C8;
            --md-sys-color-on-tertiary: #492532;
            --md-sys-color-tertiary-container: #633B48;
            --md-sys-color-on-tertiary-container: #FFD8E4;

            --md-sys-color-error: #F2B8B5;
            --md-sys-color-on-error: #601410;
            --md-sys-color-error-container: #8C1D18;
            --md-sys-color-on-error-container: #F9DEDC;

            --md-sys-color-background: #1C1B1F;
            --md-sys-color-on-background: #E6E1E5;
            --md-sys-color-surface: #1C1B1F;
            --md-sys-color-on-surface: #E6E1E5;
            --md-sys-color-surface-variant: #49454F;
            --md-sys-color-on-surface-variant: #CAC4D0;

            /* Elevated surfaces for better contrast */
            --md-sys-color-surface-1: #2B2930;
            --md-sys-color-surface-2: #322F37;
            --md-sys-color-surface-3: #38353E;
            --md-sys-color-surface-4: #3B3841;
            --md-sys-color-surface-5: #3F3B45;

            --md-sys-color-outline: #938F99;
            --md-sys-color-outline-variant: #49454F;

            --md-sys-color-surface-tint: #D0BCFF;
            --md-sys-color-inverse-surface: #E6E1E5;
            --md-sys-color-inverse-on-surface: #313033;
            --md-sys-color-inverse-primary: #6750A4;

            --md-sys-color-shadow: #000000;
            --md-sys-color-scrim: #000000;

            /* Legacy aliases */
            --background: #1C1B1F;
            --background-secondary: #49454F;
            --background-tertiary: #938F99;
            --text-primary: #E6E1E5;
            --text-secondary: #CAC4D0;
            --text-muted: #938F99;
            --primary-color: #D0BCFF;
            --secondary-color: #CCC2DC;
            --accent-color: #EFB8C8;
            --success-color: #30D158;
            --warning-color: #FF9F0A;
            --accent-blue: #D0BCFF;
            --accent-green: #30D158;
            --accent-red: #F2B8B5;
            --accent-orange: #FF9F0A;
            --bg-primary: #1C1B1F;
            --bg-secondary: #49454F;
            --bg-card: #1C1B1F;
            --bg-highlight: #49454F;
            --bg-accent: #4F378B;
            --border: #938F99;
            --border-color: #938F99;
            --border-hover: #CAC4D0;
            --border-strong: #E6E1E5;
            --shadow: rgba(0, 0, 0, 0.5);
            --shadow-sm: 0px 1px 2px 0px rgba(0, 0, 0, 0.3), 0px 1px 3px 1px rgba(0, 0, 0, 0.15);
            --shadow-md: 0px 1px 2px 0px rgba(0, 0, 0, 0.3), 0px 2px 6px 2px rgba(0, 0, 0, 0.15);
            --shadow-lg: 0px 1px 3px 0px rgba(0, 0, 0, 0.3), 0px 4px 8px 3px rgba(0, 0, 0, 0.15);
            --chart-bg: #1C1B1F;
            --chart-grid: #49454F;
            --chart-text: #E6E1E5;
        }

        /* テーマカラー設定 */
        /* Purple (デフォルト) */
        :root[data-color-theme="purple"],
        :root:not([data-color-theme]) {
            --md-sys-color-primary: #6750A4;
            --md-sys-color-on-primary: #FFFFFF;
            --md-sys-color-primary-container: #EADDFF;
            --md-sys-color-on-primary-container: #21005D;
            --md-sys-color-surface-tint: #6750A4;
            --md-sys-color-inverse-primary: #D0BCFF;
        }

        /* Blue */
        :root[data-color-theme="blue"] {
            --md-sys-color-primary: #1976D2;
            --md-sys-color-on-primary: #FFFFFF;
            --md-sys-color-primary-container: #BBDEFB;
            --md-sys-color-on-primary-container: #0D47A1;
            --md-sys-color-surface-tint: #1976D2;
            --md-sys-color-inverse-primary: #64B5F6;
        }

        /* Green */
        :root[data-color-theme="green"] {
            --md-sys-color-primary: #388E3C;
            --md-sys-color-on-primary: #FFFFFF;
            --md-sys-color-primary-container: #C8E6C9;
            --md-sys-color-on-primary-container: #1B5E20;
            --md-sys-color-surface-tint: #388E3C;
            --md-sys-color-inverse-primary: #81C784;
        }

        /* Teal */
        :root[data-color-theme="teal"] {
            --md-sys-color-primary: #00897B;
            --md-sys-color-on-primary: #FFFFFF;
            --md-sys-color-primary-container: #B2DFDB;
            --md-sys-color-on-primary-container: #004D40;
            --md-sys-color-surface-tint: #00897B;
            --md-sys-color-inverse-primary: #4DB6AC;
        }

        /* Red */
        :root[data-color-theme="red"] {
            --md-sys-color-primary: #D32F2F;
            --md-sys-color-on-primary: #FFFFFF;
            --md-sys-color-primary-container: #FFCDD2;
            --md-sys-color-on-primary-container: #B71C1C;
            --md-sys-color-surface-tint: #D32F2F;
            --md-sys-color-inverse-primary: #EF5350;
        }

        /* Orange */
        :root[data-color-theme="orange"] {
            --md-sys-color-primary: #F57C00;
            --md-sys-color-on-primary: #FFFFFF;
            --md-sys-color-primary-container: #FFE0B2;
            --md-sys-color-on-primary-container: #E65100;
            --md-sys-color-surface-tint: #F57C00;
            --md-sys-color-inverse-primary: #FF9800;
        }

        /* Remove gaming effects from dark mode header */
        /* Material Design 3 Dark Theme Top App Bar */
        [data-theme="dark"] .header {
            background: var(--md-sys-color-surface);
            box-shadow: 0px 1px 2px 0px rgba(0, 0, 0, 0.3), 0px 2px 6px 2px rgba(0, 0, 0, 0.15);
            border-bottom: none;
        }

        /* Material Design 3 dark theme uses the same elevation system */

        /* Material Design 3 Segmented Button for Theme Toggle */
        .theme-toggle {
            position: relative;
            display: inline-flex;
            align-items: center;
            background: transparent;
            border: 1px solid var(--md-sys-color-outline);
            border-radius: 20px;
            padding: 0;
            cursor: pointer;
            transition: all 200ms cubic-bezier(0.2, 0, 0, 1);
            overflow: hidden;
        }

        .theme-toggle:hover {
            border-color: var(--md-sys-color-on-surface);
        }

        .theme-option {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 10px 24px;
            border-radius: 0;
            transition: all 200ms cubic-bezier(0.2, 0, 0, 1);
            cursor: pointer;
            font-family: 'Roboto', sans-serif;
            font-size: 14px;
            font-weight: 500;
            letter-spacing: 0.1px;
            white-space: nowrap;
            border-right: 1px solid var(--md-sys-color-outline);
            overflow: hidden;
        }

        .theme-option:last-child {
            border-right: none;
        }

        .theme-option::before {
            content: '';
            position: absolute;
            inset: 0;
            background-color: var(--md-sys-color-on-surface);
            opacity: 0;
            transition: opacity 200ms cubic-bezier(0.2, 0, 0, 1);
        }

        .theme-option:hover::before {
            opacity: 0.08;
        }

        .theme-option.active {
            background: var(--md-sys-color-secondary-container);
            color: var(--md-sys-color-on-secondary-container);
        }

        .theme-option.active::before {
            background-color: var(--md-sys-color-on-secondary-container);
            opacity: 0.12;
        }

        .theme-option:not(.active) {
            color: var(--md-sys-color-on-surface);
        }

        body {
            font-family: 'Roboto', 'Noto Sans', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            background-image: url('./しりすこPADヘッダー.PNG');
            background-size: contain;
            background-position: top center;
            background-repeat: no-repeat;
            background-attachment: scroll;
            background-color: var(--md-sys-color-background);
            color: var(--md-sys-color-on-background);
            line-height: 1.5;
            font-size: 16px;
            font-weight: 400;
            letter-spacing: 0.5px;
        }

        /* PC用: 背景を固定して大きく表示 */
        @media (min-width: 769px) {
            body {
                background-size: cover;
                background-attachment: fixed;
            }
        }

        /* スマホ用: 背景を縮小して見やすく */
        @media (max-width: 768px) {
            body {
                background-size: 100% auto;
                background-attachment: scroll;
            }
        }

        /* 背景画像を上部だけに表示するためのグラデーション */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(to bottom,
                rgba(255, 255, 255, 0.2) 0%,
                rgba(255, 255, 255, 0.4) 200px,
                rgba(255, 255, 255, 0.7) 400px,
                var(--md-sys-color-background) 700px);
            pointer-events: none;
            z-index: -1;
        }

        /* スマホ用: グラデーションを早めに適用して視認性向上 */
        @media (max-width: 768px) {
            body::before {
                background: linear-gradient(to bottom,
                    rgba(255, 255, 255, 0.1) 0%,
                    rgba(255, 255, 255, 0.5) 150px,
                    rgba(255, 255, 255, 0.8) 300px,
                    var(--md-sys-color-background) 500px);
            }
        }

        /* ダークモード用の背景オーバーレイ */
        [data-theme="dark"] body::before {
            background: linear-gradient(to bottom,
                rgba(28, 27, 31, 0.2) 0%,
                rgba(28, 27, 31, 0.4) 200px,
                rgba(28, 27, 31, 0.7) 400px,
                var(--md-sys-color-background) 700px);
        }

        /* ダークモード スマホ用 */
        @media (max-width: 768px) {
            [data-theme="dark"] body::before {
                background: linear-gradient(to bottom,
                    rgba(28, 27, 31, 0.1) 0%,
                    rgba(28, 27, 31, 0.5) 150px,
                    rgba(28, 27, 31, 0.8) 300px,
                    var(--md-sys-color-background) 500px);
            }
        }

        /* Material Design 3 Typography Scale */
        h1 {
            font-family: 'Roboto', sans-serif;
            font-size: 32px;
            font-weight: 400;
            line-height: 40px;
            letter-spacing: 0;
        }

        h2 {
            font-family: 'Roboto', sans-serif;
            font-size: 28px;
            font-weight: 400;
            line-height: 36px;
            letter-spacing: 0;
        }

        h3 {
            font-family: 'Roboto', sans-serif;
            font-size: 24px;
            font-weight: 400;
            line-height: 32px;
            letter-spacing: 0;
        }

        h4 {
            font-family: 'Roboto', sans-serif;
            font-size: 22px;
            font-weight: 400;
            line-height: 28px;
            letter-spacing: 0;
        }

        small {
            font-size: 12px;
            line-height: 16px;
            letter-spacing: 0.4px;
        }

        /* Material Design 3 Elevation System */
        .md-elevation-0 {
            box-shadow: none;
        }

        .md-elevation-1 {
            box-shadow: 0px 1px 2px 0px rgba(0, 0, 0, 0.3), 0px 1px 3px 1px rgba(0, 0, 0, 0.15);
        }

        .md-elevation-2 {
            box-shadow: 0px 1px 2px 0px rgba(0, 0, 0, 0.3), 0px 2px 6px 2px rgba(0, 0, 0, 0.15);
        }

        .md-elevation-3 {
            box-shadow: 0px 1px 3px 0px rgba(0, 0, 0, 0.3), 0px 4px 8px 3px rgba(0, 0, 0, 0.15);
        }

        .md-elevation-4 {
            box-shadow: 0px 2px 3px 0px rgba(0, 0, 0, 0.3), 0px 6px 10px 4px rgba(0, 0, 0, 0.15);
        }

        .md-elevation-5 {
            box-shadow: 0px 4px 4px 0px rgba(0, 0, 0, 0.3), 0px 8px 12px 6px rgba(0, 0, 0, 0.15);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 32px 16px;
        }

        /* Material Design 3 Top App Bar */
        .header {
            text-align: center;
            margin-bottom: 0;
            padding: 16px 24px;
            background: var(--md-sys-color-surface);
            color: var(--md-sys-color-on-surface);
            border-bottom: none;
            position: sticky;
            top: 0;
            z-index: 1000;
            box-shadow: 0px 1px 2px 0px rgba(0, 0, 0, 0.3), 0px 2px 6px 2px rgba(0, 0, 0, 0.15);
            transition: box-shadow 200ms cubic-bezier(0.2, 0, 0, 1);
        }

        .header h1 {
            font-family: 'Roboto', sans-serif;
            font-size: 28px;
            font-weight: 400;
            line-height: 36px;
            letter-spacing: 0;
            margin-bottom: 4px;
            color: var(--md-sys-color-on-surface);
        }

        .header p {
            font-family: 'Roboto', sans-serif;
            font-size: 14px;
            font-weight: 400;
            line-height: 20px;
            letter-spacing: 0.25px;
            opacity: 0.87;
            color: var(--md-sys-color-on-surface-variant);
            margin-top: 0;
        }

        /* Material Design 3 Elevated Card */
        .card {
            background: var(--md-sys-color-surface-1, var(--md-sys-color-surface));
            color: var(--md-sys-color-on-surface);
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0px 1px 2px 0px rgba(0, 0, 0, 0.3), 0px 1px 3px 1px rgba(0, 0, 0, 0.15);
            border: none;
            margin-bottom: 16px;
            transition: box-shadow 200ms cubic-bezier(0.2, 0, 0, 1);
            overflow: hidden;
        }

        .card:hover {
            box-shadow: 0px 1px 3px 0px rgba(0, 0, 0, 0.3), 0px 4px 8px 3px rgba(0, 0, 0, 0.15);
        }

        .upload-area {
            border: 2px dashed var(--md-sys-color-outline-variant);
            border-radius: 12px;
            padding: 48px 32px;
            text-align: center;
            cursor: pointer;
            transition: all 200ms cubic-bezier(0.2, 0, 0, 1);
            background: var(--md-sys-color-surface-variant);
        }

        .upload-area:hover {
            border-color: var(--md-sys-color-primary);
            background: var(--md-sys-color-surface);
        }

        .upload-area.dragover {
            border-color: var(--md-sys-color-primary);
            background: var(--md-sys-color-primary-container);
        }

        .upload-area h3 {
            font-size: 24px;
            font-weight: 400;
            margin-bottom: 8px;
            color: var(--md-sys-color-on-surface-variant);
            letter-spacing: 0;
        }

        .upload-area p {
            color: var(--md-sys-color-on-surface-variant);
            margin-bottom: 8px;
            font-size: 16px;
            letter-spacing: 0.5px;
        }

        .upload-area small {
            color: var(--md-sys-color-on-surface-variant);
            font-size: 12px;
            letter-spacing: 0.4px;
        }

        /* Material Design 3 Button System */
        .btn {
            position: relative;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            height: 40px;
            padding: 0 24px;
            border-radius: 20px;
            font-family: 'Roboto', sans-serif;
            font-size: 14px;
            font-weight: 500;
            letter-spacing: 0.1px;
            text-transform: none;
            cursor: pointer;
            overflow: hidden;
            transition: box-shadow 200ms cubic-bezier(0.2, 0, 0, 1);
            text-decoration: none;
            gap: 8px;
            border: none;
        }

        /* Filled Button (Primary - Highest emphasis) */
        .btn-primary {
            background-color: var(--md-sys-color-primary);
            color: var(--md-sys-color-on-primary);
            box-shadow: 0px 1px 2px 0px rgba(0, 0, 0, 0.3), 0px 1px 3px 1px rgba(0, 0, 0, 0.15);
        }

        .btn-primary:hover {
            box-shadow: 0px 1px 2px 0px rgba(0, 0, 0, 0.3), 0px 2px 6px 2px rgba(0, 0, 0, 0.15);
        }

        .btn-primary::before {
            content: '';
            position: absolute;
            inset: 0;
            background-color: var(--md-sys-color-on-primary);
            opacity: 0;
            transition: opacity 200ms cubic-bezier(0.2, 0, 0, 1);
        }

        .btn-primary:hover::before {
            opacity: 0.08;
        }

        .btn-primary:active::before {
            opacity: 0.12;
        }

        /* Filled Tonal Button (Secondary - Medium emphasis) */
        .btn-secondary {
            background-color: var(--md-sys-color-secondary-container);
            color: var(--md-sys-color-on-secondary-container);
            box-shadow: none;
        }

        .btn-secondary::before {
            content: '';
            position: absolute;
            inset: 0;
            background-color: var(--md-sys-color-on-secondary-container);
            opacity: 0;
            transition: opacity 200ms cubic-bezier(0.2, 0, 0, 1);
        }

        .btn-secondary:hover::before {
            opacity: 0.08;
        }

        .btn-secondary:active::before {
            opacity: 0.12;
        }

        /* Outlined Button (Medium-low emphasis) */
        .btn-outline {
            background-color: transparent;
            color: var(--md-sys-color-primary);
            border: 1px solid var(--md-sys-color-outline);
        }

        .btn-outline::before {
            content: '';
            position: absolute;
            inset: 0;
            background-color: var(--md-sys-color-primary);
            opacity: 0;
            transition: opacity 200ms cubic-bezier(0.2, 0, 0, 1);
        }

        .btn-outline:hover::before {
            opacity: 0.08;
        }

        .btn-outline:active::before {
            opacity: 0.12;
        }

        /* Theme Color Button */
        .theme-color-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 20px 16px;
            border: 3px solid transparent;
            border-radius: 16px;
            color: white;
            font-family: 'Roboto', sans-serif;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }

        .theme-color-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
        }

        .theme-color-btn:active {
            transform: translateY(0);
        }

        .theme-color-btn::before {
            content: '';
            position: absolute;
            inset: 0;
            background: rgba(255, 255, 255, 0.1);
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .theme-color-btn:hover::before {
            opacity: 1;
        }

        .theme-color-btn.active {
            border-color: white;
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.5), 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        /* Text Button (Lowest emphasis) */
        .btn-text {
            background-color: transparent;
            color: var(--md-sys-color-primary);
            padding: 0 12px;
        }

        .btn-text::before {
            content: '';
            position: absolute;
            inset: 0;
            background-color: var(--md-sys-color-primary);
            opacity: 0;
            transition: opacity 200ms cubic-bezier(0.2, 0, 0, 1);
        }

        .btn-text:hover::before {
            opacity: 0.08;
        }

        .btn-text:active::before {
            opacity: 0.12;
        }

        /* Small Button Variant */
        .btn-sm {
            height: 32px;
            padding: 0 16px;
            font-size: 12px;
        }

        /* Attribute Tab Buttons */
        .attribute-tab-btn {
            position: relative;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            background-color: var(--md-sys-color-surface-2, var(--md-sys-color-surface-variant));
            color: var(--md-sys-color-on-surface);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 200ms cubic-bezier(0.2, 0, 0, 1);
            outline: none;
        }

        .attribute-tab-btn:hover {
            background-color: var(--md-sys-color-secondary-container);
            color: var(--md-sys-color-on-secondary-container);
        }

        .attribute-tab-btn.active {
            background-color: var(--md-sys-color-primary-container);
            color: var(--md-sys-color-on-primary-container);
            font-weight: 600;
        }

        .attribute-tab-btn img {
            flex-shrink: 0;
        }

        /* Ensure text is above state layer */
        .btn > * {
            position: relative;
            z-index: 1;
        }

        /* Material Design 3 FAB (Floating Action Button) */
        .md-fab {
            position: fixed;
            bottom: 16px;
            right: 16px;
            width: 56px;
            height: 56px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: none;
            border-radius: 16px;
            background-color: var(--md-sys-color-primary-container);
            color: var(--md-sys-color-on-primary-container);
            cursor: pointer;
            overflow: hidden;
            transition: box-shadow 200ms cubic-bezier(0.2, 0, 0, 1);
            box-shadow: 0px 1px 3px 0px rgba(0, 0, 0, 0.3), 0px 4px 8px 3px rgba(0, 0, 0, 0.15);
            z-index: 999;
        }

        .md-fab::before {
            content: '';
            position: absolute;
            inset: 0;
            background-color: var(--md-sys-color-on-primary-container);
            opacity: 0;
            transition: opacity 200ms cubic-bezier(0.2, 0, 0, 1);
        }

        .md-fab:hover {
            box-shadow: 0px 2px 3px 0px rgba(0, 0, 0, 0.3), 0px 6px 10px 4px rgba(0, 0, 0, 0.15);
        }

        .md-fab:hover::before {
            opacity: 0.08;
        }

        .md-fab:active::before {
            opacity: 0.12;
        }

        .md-fab-icon {
            position: relative;
            z-index: 1;
            font-size: 24px;
        }

        /* Extended FAB */
        .md-fab-extended {
            width: auto;
            padding: 0 16px;
            gap: 12px;
            border-radius: 16px;
        }

        .md-fab-label {
            position: relative;
            z-index: 1;
            font-family: 'Roboto', sans-serif;
            font-size: 14px;
            font-weight: 500;
            letter-spacing: 0.1px;
        }

        /* Icon Button with proper Material Design 3 specs */
        .md-icon-button {
            position: relative;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: none;
            border-radius: 20px;
            background-color: transparent;
            color: var(--md-sys-color-on-surface-variant);
            cursor: pointer;
            overflow: hidden;
            transition: background-color 200ms cubic-bezier(0.2, 0, 0, 1);
        }

        .md-icon-button::before {
            content: '';
            position: absolute;
            inset: 0;
            background-color: currentColor;
            opacity: 0;
            transition: opacity 200ms cubic-bezier(0.2, 0, 0, 1);
        }

        .md-icon-button:hover::before {
            opacity: 0.08;
        }

        .md-icon-button:focus::before {
            opacity: 0.12;
        }

        .md-icon-button:active::before {
            opacity: 0.12;
        }

        .md-icon-button-icon {
            position: relative;
            z-index: 1;
            font-size: 24px;
        }

        .button-group {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 32px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 24px;
            margin-bottom: 32px;
        }

        /* Material Design 3 Stat Card (Filled Card) */
        .stat-card {
            background: var(--md-sys-color-surface-1, var(--md-sys-color-surface-variant));
            color: var(--md-sys-color-on-surface);
            border-radius: 12px;
            padding: 24px;
            text-align: center;
            border: none;
            transition: box-shadow 200ms cubic-bezier(0.2, 0, 0, 1);
            box-shadow: 0px 1px 2px 0px rgba(0, 0, 0, 0.3), 0px 1px 3px 1px rgba(0, 0, 0, 0.15);
        }

        .stat-card:hover {
            box-shadow: 0px 1px 3px 0px rgba(0, 0, 0, 0.3), 0px 4px 8px 3px rgba(0, 0, 0, 0.15);
        }

        .stat-card h3 {
            font-family: 'Roboto', sans-serif;
            font-size: 12px;
            font-weight: 500;
            line-height: 16px;
            letter-spacing: 0.5px;
            color: var(--md-sys-color-on-surface-variant);
            margin-bottom: 8px;
            text-transform: uppercase;
        }

        .stat-card .value {
            font-family: 'Roboto', sans-serif;
            font-size: 32px;
            font-weight: 400;
            line-height: 40px;
            letter-spacing: 0;
            color: var(--md-sys-color-primary);
            font-variant-numeric: tabular-nums;
        }

        .char-usage-card {
            position: relative;
            padding: 1.5rem 1rem;
            text-align: center;
        }

        .rank-badge {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background: var(--primary-color);
            color: white;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.875rem;
            font-weight: 700;
        }

        .char-usage-icon {
            width: 80px;
            height: 80px;
            border-radius: 12px;
            border: 3px solid var(--border-color);
            margin: 0 auto;
            display: block;
            object-fit: cover;
        }

        [data-theme="dark"] .char-usage-icon {
            box-shadow: 0 0 15px rgba(139, 92, 246, 0.3);
        }

        .controls {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            align-items: center;
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: var(--bg-secondary);
            border-radius: 12px;
            border: 1px solid var(--border-color);
        }

        .form-input, .form-select {
            padding: 0.75rem 1rem;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: var(--bg-card);
            color: var(--text-primary);
            font-size: 0.875rem;
            min-width: 150px;
            transition: all 0.2s ease;
        }

        .form-input:focus, .form-select:focus {
            outline: none;
            border-color: var(--accent-blue);
            box-shadow: 0 0 0 4px rgba(0, 122, 255, 0.1);
        }

        .form-input::placeholder {
            color: var(--text-muted);
        }

        .data-table {
            background: var(--bg-card);
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow-md);
        }

        /* Apple Table Style */
        table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            background: var(--background);
            border-radius: 12px;
            overflow: hidden;
        }

        thead th {
            background: var(--background-secondary);
            padding: 12px 16px;
            text-align: left;
            font-weight: 600;
            font-size: 13px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        tbody tr {
            border-top: 1px solid var(--border);
        }

        tbody td {
            padding: 16px;
            font-size: 17px;
            color: var(--text-primary);
            font-variant-numeric: tabular-nums;
        }

        tbody tr:hover {
            background: var(--background-secondary);
        }

        .rank {
            font-weight: 700;
            font-size: 17px;
        }

        .rank-1 { color: var(--accent-orange); }
        .rank-2 { color: var(--text-secondary); }
        .rank-3 { color: #CD7F32; }

        /* Apple Badge Style */
        /* Material Design 3 Badge (Label) */
        .badge {
            display: inline-flex;
            align-items: center;
            padding: 4px 8px;
            border-radius: 8px;
            font-family: 'Roboto', sans-serif;
            font-size: 11px;
            font-weight: 500;
            line-height: 16px;
            letter-spacing: 0.5px;
            margin-left: 8px;
        }

        .badge-union {
            background: var(--md-sys-color-tertiary-container);
            color: var(--md-sys-color-on-tertiary-container);
        }

        .badge-hard {
            background: var(--md-sys-color-error-container);
            color: var(--md-sys-color-on-error-container);
            padding: 4px 8px;
            border-radius: 8px;
            font-family: 'Roboto', sans-serif;
            font-size: 11px;
            font-weight: 500;
            line-height: 16px;
            letter-spacing: 0.5px;
            text-transform: uppercase;
        }

        .badge-normal {
            background: var(--md-sys-color-tertiary-container);
            color: var(--md-sys-color-on-tertiary-container);
            padding: 4px 8px;
            border-radius: 8px;
            font-family: 'Roboto', sans-serif;
            font-size: 11px;
            font-weight: 500;
            line-height: 16px;
            letter-spacing: 0.5px;
            text-transform: uppercase;
        }

        .badge-easy {
            background: var(--md-sys-color-primary-container);
            color: var(--md-sys-color-on-primary-container);
            padding: 4px 8px;
            border-radius: 8px;
            font-family: 'Roboto', sans-serif;
            font-size: 11px;
            font-weight: 500;
            line-height: 16px;
            letter-spacing: 0.5px;
            text-transform: uppercase;
        }

        .btn-outline {
            background: transparent;
            border: 1px solid var(--primary-color);
            color: var(--primary-color);
        }

        .btn-outline:hover {
            background: var(--primary-color);
            color: white;
        }

        .attack-details-row {
            background: var(--bg-secondary);
            border-left: 4px solid var(--primary-color);
        }

        .attack-details-container {
            padding: 1.5rem;
            background: var(--bg-card);
            border-radius: 8px;
            margin: 1rem;
            box-shadow: var(--shadow-md);
        }

        .attack-details-container h4 {
            margin-top: 0;
            margin-bottom: 1rem;
            color: var(--text-primary);
            font-size: 1.125rem;
        }

        .attack-details-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
        }

        .attack-details-table th {
            background: var(--bg-highlight);
            padding: 0.75rem;
            text-align: left;
            font-size: 0.875rem;
            color: var(--text-secondary);
            font-weight: 600;
            border-bottom: 2px solid var(--border-color);
        }

        .attack-details-table td {
            padding: 0.75rem;
            border-bottom: 1px solid var(--border-color);
            vertical-align: middle;
            font-size: 0.875rem;
        }

        .attack-details-table tbody tr:hover {
            background: var(--bg-highlight);
        }

        .boss-code {
            color: var(--text-muted);
            font-size: 0.875rem;
            margin-left: 0.25rem;
        }

        .character-icons {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 0.5rem;
            max-width: 400px; /* PC版でアイコンが大きくなりすぎないように制限 */
        }

        .char-icon {
            width: 100%;
            aspect-ratio: 1 / 1;
            border-radius: 8px;
            border: 2px solid var(--border-color);
            transition: all 0.2s ease;
            object-fit: cover;
        }

        .char-icon:hover {
            transform: scale(1.2);
            border-color: var(--primary-color);
            cursor: pointer;
            box-shadow: var(--shadow-lg);
            z-index: 10;
        }

        .char-icon.error {
            opacity: 0.3;
            border-color: var(--warning-color);
        }

        [data-theme="dark"] .char-icon:hover {
            box-shadow: 0 0 20px rgba(139, 92, 246, 0.5);
        }

        /* Material Design 3 Responsive Breakpoints */
        /* Compact (Phone): 0-599dp */
        /* Medium (Tablet): 600-839dp */
        /* Expanded (Desktop): 840dp+ */

        /* Compact devices (phones, up to 599px) */
        @media (max-width: 599px) {
            .character-icons,
            .attack-characters {
                max-width: 100%;
            }
        }

        /* Medium devices (tablets, 600px and up) */
        @media (min-width: 600px) {
            .container {
                padding: 24px;
            }

            .stats-grid {
                grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            }

            .header {
                padding: 20px 24px;
            }
        }

        /* Expanded devices (desktop, 840px and up) */
        @media (min-width: 840px) {
            .container {
                max-width: 1240px;
                padding: 32px;
            }

            .stats-grid {
                grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            }

            .button-group {
                flex-direction: row;
                flex-wrap: wrap;
            }

            .md-fab {
                bottom: 24px;
                right: 24px;
            }
        }

        /* Large expanded (large desktop, 1240px and up) */
        @media (min-width: 1240px) {
            .container {
                max-width: 1440px;
            }
        }

        /* Compact devices (phones) - override for mobile */
        @media (max-width: 599px) {
            .container {
                padding: 16px 12px;
            }

            .header h1 {
                font-size: var(--md-sys-typescale-headline-medium-size);
                line-height: var(--md-sys-typescale-headline-medium-line-height);
            }

            .stats-grid {
                grid-template-columns: 1fr;
                gap: 12px;
            }

            .button-group {
                flex-direction: column;
            }

            .btn {
                width: 100%;
            }

            .tab-button {
                min-width: 60px;
                padding: 12px 12px 10px;
                font-size: 12px;
            }

            .md-fab {
                bottom: 12px;
                right: 12px;
                width: 48px;
                height: 48px;
            }
        }

        @media (max-width: 768px) {
            .attack-details-table {
                font-size: 0.75rem;
            }

            .attack-details-table th,
            .attack-details-table td {
                padding: 0.5rem;
            }

            .character-icons {
                gap: 0.25rem;
            }

            .attack-characters {
                gap: 0.25rem;
            }

            .attack-details-container {
                padding: 1rem;
                margin: 0.5rem;
            }

            .btn-sm {
                font-size: 0.625rem;
                padding: 0.2rem 0.5rem;
            }
        }

        .chart-container {
            background: var(--chart-bg);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 2rem;
            height: 500px;
            border: 2px solid var(--border-color);
            box-shadow: var(--shadow-md);
            /* チャートエリアの強調と視認性向上 */
            border-left: 4px solid var(--primary-color);
            position: relative;
            display: flex;
            flex-direction: column;
        }

        .chart-container::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--background-secondary);
            border-radius: 10px;
            opacity: 0.3;
            pointer-events: none;
        }

        .chart-wrapper {
            flex: 1;
            position: relative;
            overflow: hidden;
            min-height: 350px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            z-index: 10;
            position: relative;
        }

        #damageChart {
            position: relative;
            z-index: 5;
            max-width: 100%;
            max-height: 100%;
        }

        .error {
            background: #fef2f2;
            border: 1px solid #fecaca;
            color: #dc2626;
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
        }

        @media (prefers-color-scheme: dark) {
            .error {
                background: #7f1d1d;
                border-color: #dc2626;
                color: #fca5a5;
            }
        }

        /* Material Design 3 Dialog */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.32);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }

        .modal-content {
            background: var(--md-sys-color-surface-3, var(--md-sys-color-surface));
            color: var(--md-sys-color-on-surface);
            border-radius: 28px;
            padding: 24px;
            max-width: 560px;
            max-height: 80vh;
            overflow-y: auto;
            width: 100%;
            box-shadow: 0px 1px 3px 0px rgba(0, 0, 0, 0.3), 0px 4px 8px 3px rgba(0, 0, 0, 0.15);
            border: none;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            padding-bottom: 0;
            border-bottom: none;
        }

        .modal-header h3 {
            font-family: 'Roboto', sans-serif;
            font-size: 24px;
            font-weight: 400;
            line-height: 32px;
            letter-spacing: 0;
            color: var(--md-sys-color-on-surface);
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text-muted);
            padding: 0.25rem;
            border-radius: 4px;
        }

        .close-btn:hover {
            color: var(--text-primary);
            background: var(--bg-secondary);
        }

        .year-month-input {
            width: 140px;
            padding: 1rem;
            font-size: 2rem;
            text-align: center;
            border: 2px solid var(--border-color);
            border-radius: 12px;
            background: var(--bg-card);
            color: var(--text-primary);
            font-weight: 600;
            transition: all 0.2s ease;
        }

        .year-month-input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }

        .year-month-input::-webkit-inner-spin-button,
        .year-month-input::-webkit-outer-spin-button {
            opacity: 1;
            height: 50px;
        }

        .guide-section {
            margin-bottom: 2rem;
        }

        .guide-section h4 {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--primary-color);
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid var(--border-color);
        }

        .guide-steps {
            counter-reset: step-counter;
            list-style: none;
            padding: 0;
        }

        .guide-steps li {
            counter-increment: step-counter;
            margin-bottom: 1.5rem;
            padding-left: 3rem;
            position: relative;
        }

        .guide-steps li::before {
            content: counter(step-counter);
            position: absolute;
            left: 0;
            top: 0;
            background: var(--primary-color);
            color: white;
            width: 2rem;
            height: 2rem;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 0.875rem;
        }

        .guide-steps li strong {
            display: block;
            color: var(--text-primary);
            margin-bottom: 0.25rem;
        }

        .guide-steps li p {
            color: var(--text-secondary);
            font-size: 0.875rem;
            margin: 0;
        }

        .guide-warning {
            background: #fef3c7;
            border-left: 4px solid #f59e0b;
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
        }

        [data-theme="dark"] .guide-warning {
            background: rgba(245, 158, 11, 0.1);
            border-left-color: #f59e0b;
        }

        .guide-warning p {
            margin: 0;
            color: var(--text-primary);
            font-size: 0.875rem;
        }

        .guide-list {
            list-style: none;
            padding: 0;
        }

        .guide-list li {
            padding: 0.5rem 0;
            padding-left: 1.5rem;
            position: relative;
            color: var(--text-secondary);
            font-size: 0.875rem;
        }

        .guide-list li::before {
            content: "✓";
            position: absolute;
            left: 0;
            color: var(--success-color);
            font-weight: bold;
        }

        .guide-faq {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .faq-item {
            background: var(--bg-secondary);
            padding: 1rem;
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .faq-item strong {
            display: block;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
            font-size: 0.875rem;
        }

        .faq-item p {
            margin: 0;
            color: var(--text-secondary);
            font-size: 0.875rem;
        }

        .sync-level-item {
            display: flex;
            align-items: center;
            margin-bottom: 1rem;
            padding: 1rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            gap: 1rem;
        }

        .sync-level-item:hover {
            border-color: var(--primary-color);
        }

        .sync-level-item .player-info {
            flex: 1;
            min-width: 0;
        }

        .sync-level-item .player-name {
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.25rem;
        }

        .sync-level-item .player-damage {
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .sync-level-controls {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .sync-level-controls input[type="number"] {
            width: 80px;
            padding: 0.5rem;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            background: var(--bg-card);
            color: var(--text-primary);
            text-align: center;
            font-size: 0.875rem;
        }

        .bulk-controls {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .bulk-controls h4 {
            margin-bottom: 1rem;
            color: var(--text-primary);
            font-weight: 600;
        }

        .bulk-input-group {
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .results {
            display: none;
        }

        .animate-fade-in {
            animation: fadeIn 0.3s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes slideInRight {
            from {
                opacity: 0;
                transform: translateX(100px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes slideOutRight {
            from {
                opacity: 1;
                transform: translateX(0);
            }
            to {
                opacity: 0;
                transform: translateX(100px);
            }
        }

        #fileInput {
            display: none;
        }

        @media (max-width: 768px) {
            .container {
                padding: 1rem 0.5rem;
            }

            .header h1 {
                font-size: 2rem;
            }

            .stats-grid {
                grid-template-columns: 1fr;
            }

            .controls {
                flex-direction: column;
                align-items: stretch;
            }

            .form-input, .form-select {
                min-width: auto;
                width: 100%;
            }

            .button-group {
                flex-direction: column;
            }

            .sync-level-item {
                flex-direction: column;
                align-items: stretch;
                gap: 1rem;
            }

            .sync-level-controls {
                justify-content: center;
            }

            .bulk-input-group {
                flex-direction: column;
                align-items: stretch;
            }

            .chart-container {
                height: 450px;
                padding: 1rem;
            }

            .chart-wrapper {
                min-height: 300px;
            }

            .chart-header {
                flex-direction: column;
                gap: 1rem;
                align-items: stretch;
            }
        }

        /* クリック可能なプレイヤー行のスタイル */
        .player-row {
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .player-row:hover {
            background: var(--bg-highlight);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .player-row:hover td {
            color: var(--primary-color);
        }

        .player-row:active {
            transform: translateY(0);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
        }

        /* プレイヤー名を太字にする */
        .player-row td:nth-child(2) strong {
            font-weight: 700;
        }

        /* プレイヤー詳細モーダルのスタイル */
        .player-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            z-index: 1000;
            display: flex;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(6px);
            -webkit-backdrop-filter: blur(6px);
        }

        .player-modal-content {
            background: var(--card-bg);
            border-radius: 16px;
            width: 90%;
            max-width: 850px;
            max-height: 90vh;
            overflow-y: auto;
            animation: modalFadeIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* ライトモード用のモーダルコンテンツ */
        [data-theme="light"] .player-modal-content {
            background: rgba(255, 255, 255, 0.95);
            box-shadow:
                0 25px 50px rgba(0, 0, 0, 0.3),
                0 0 0 1px rgba(255, 255, 255, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        /* ダークモード用のモーダルコンテンツ */
        [data-theme="dark"] .player-modal-content {
            background: rgba(31, 41, 55, 0.95);
            border: 1px solid rgba(75, 85, 99, 0.3);
            box-shadow:
                0 25px 50px rgba(0, 0, 0, 0.6),
                0 0 0 1px rgba(255, 255, 255, 0.05),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        @keyframes modalFadeIn {
            from {
                opacity: 0;
                transform: scale(0.9) translateY(-20px);
            }
            to {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        .player-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1.5rem;
            border-bottom: 2px solid var(--border-color);
            background: var(--background-secondary);
            border-radius: 18px 18px 0 0;
        }

        .player-modal-header h2 {
            margin: 0;
            color: var(--text-primary);
            font-size: 28px;
            font-weight: 600;
            letter-spacing: -0.4px;
        }

        .close-btn {
            background: none;
            border: none;
            color: white;
            font-size: 2rem;
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .close-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        .player-modal-body {
            padding: 1.5rem;
        }

        .player-attacks-section {
            margin-bottom: 2rem;
        }

        .player-attacks-section h3 {
            color: var(--text-color);
            margin-bottom: 1rem;
            font-size: 1.2rem;
        }

        .attribute-attack-group {
            margin-bottom: 1.5rem;
            padding: 1rem;
            border-radius: 12px;
            background: var(--background-secondary);
        }

        .attribute-attack-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid rgba(var(--border-color-rgb, 229, 231, 235), 0.3);
        }

        .attribute-attack-icon {
            width: 32px;
            height: 32px;
            object-fit: contain;
        }

        .attribute-attack-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-color);
        }

        .attack-item {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            border-radius: 8px;
            background: var(--background-color);
        }

        .attack-characters {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 0.5rem;
            max-width: 400px; /* PC版でアイコンが大きくなりすぎないように制限 */
        }

        .attack-character-img {
            width: 100%;
            aspect-ratio: 1 / 1;
            border-radius: 6px;
            object-fit: cover;
            border: 2px solid var(--border-color);
        }

        .attack-damage {
            margin-left: auto;
            font-weight: 600;
            color: var(--text-color);
            font-size: 0.95rem;
        }

        .player-history-section {
            margin-bottom: 2rem;
        }

        .player-history-section h3 {
            color: var(--text-color);
            margin-bottom: 1rem;
            font-size: 1.2rem;
        }

        .player-history-table-container {
            overflow-x: auto;
        }

        .player-history-table {
            width: 100%;
            border-collapse: collapse;
            border-radius: 12px;
            overflow: hidden;
            box-shadow:
                0 8px 25px rgba(0, 0, 0, 0.1),
                0 0 0 1px rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        /* ライトモード用のテーブル背景 */
        [data-theme="light"] .player-history-table {
            background: rgba(255, 255, 255, 0.95);
        }

        /* ダークモード用のテーブル背景 */
        [data-theme="dark"] .player-history-table {
            background: rgba(31, 41, 55, 0.95);
            box-shadow:
                0 8px 25px rgba(0, 0, 0, 0.4),
                0 0 0 1px rgba(255, 255, 255, 0.1);
        }

        .player-history-table th {
            background: var(--background-secondary);
            color: var(--text-secondary);
            padding: 16px 12px;
            text-align: left;
            font-weight: 600;
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .player-history-table td {
            padding: 14px 12px;
            border-bottom: 1px solid rgba(var(--border-color-rgb, 229, 231, 235), 0.5);
            color: var(--text-color);
            font-weight: 500;
            background: rgba(255, 255, 255, 0.02);
        }

        /* ダークモードでのテーブルセル */
        [data-theme="dark"] .player-history-table td {
            border-bottom: 1px solid rgba(75, 85, 99, 0.5);
            background: rgba(0, 0, 0, 0.05);
        }

        .player-history-table tr:last-child td {
            border-bottom: none;
        }

        /* ライトモードでのホバー効果 */
        [data-theme="light"] .player-history-table tr:hover td {
            background: rgba(248, 250, 252, 0.8);
        }

        /* ダークモードでのホバー効果 */
        [data-theme="dark"] .player-history-table tr:hover td {
            background: rgba(55, 65, 81, 0.8);
        }

        .player-charts-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
        }

        .player-chart-container {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 2rem;
            border: 2px solid var(--border-color);
            box-shadow:
                0 8px 25px rgba(0, 0, 0, 0.15),
                0 0 0 1px rgba(255, 255, 255, 0.05),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }

        /* ライトモード用の背景 */
        [data-theme="light"] .player-chart-container {
            background: rgba(255, 255, 255, 0.95);
        }

        /* ダークモード用の背景 */
        [data-theme="dark"] .player-chart-container {
            background: rgba(31, 41, 55, 0.95);
            border-color: rgba(75, 85, 99, 0.5);
            box-shadow:
                0 8px 25px rgba(0, 0, 0, 0.4),
                0 0 0 1px rgba(255, 255, 255, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.05);
        }

        .player-chart-container:hover {
            transform: translateY(-2px);
            box-shadow:
                0 12px 35px rgba(0, 0, 0, 0.2),
                0 0 0 1px rgba(255, 255, 255, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.15);
        }

        .player-chart-container h4 {
            color: var(--text-color);
            margin: 0 0 1.5rem 0;
            font-size: 1.2rem;
            font-weight: 700;
            text-align: center;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        .player-chart-container canvas {
            width: 100% !important;
            height: 320px !important;
            border-radius: 8px;
        }

        /* 変化値のスタイル */
        .growth-positive {
            color: #22c55e;
            font-weight: 600;
        }

        .growth-negative {
            color: #ef4444;
            font-weight: 600;
        }

        .growth-neutral {
            color: #94a3b8;
        }

        /* レスポンシブ対応 */
        @media (max-width: 768px) {
            .player-modal-content {
                width: 95%;
                max-height: 95vh;
            }

            .player-charts-section {
                grid-template-columns: 1fr;
                gap: 1rem;
            }

            .player-modal-header {
                padding: 1rem;
            }

            .player-modal-body {
                padding: 1rem;
            }

            .player-chart-container canvas {
                height: 250px !important;
            }
        }

        /* クリック可能なカードのスタイル */
        .clickable-card {
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .clickable-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
        }

        .clickable-card .card-hint {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-top: 0.5rem;
            opacity: 0.7;
        }

        .clickable-card:hover .card-hint {
            opacity: 1;
            color: var(--primary-color);
        }

        /* ユニオン順位設定エリアのスタイル */
        .union-rank-setting {
            background: var(--background-secondary);
            border-left: 4px solid var(--accent-orange);
        }

        .union-rank-setting h3 {
            margin: 0 0 1rem 0;
            color: var(--text-color);
            font-size: 1.1rem;
        }

        

        

        

        

        [data-theme="dark"] 

        

        

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* データ管理タブ専用の情報ボックス */
        .storage-info-box {
            background: var(--background-secondary);
            border: 1px solid var(--border);
            border-radius: 18px;
            padding: 24px;
            margin-bottom: 24px;
        }

        .storage-info-box h4 {
            color: var(--primary-color);
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .storage-months {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 0.75rem;
        }

        .month-badge {
            padding: 0.5rem 0.75rem;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--text-primary);
        }


/* Apple Design System - Phase 1.5追加 */

/* フォント: San Francisco Pro風のシステムフォント */
body {
    font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', system-ui, sans-serif;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}

/* Apple Segmented Control Style Tabs */
.tab-navigation {
    background: rgba(255, 255, 255, 0.8);
    backdrop-filter: saturate(180%) blur(20px);
    -webkit-backdrop-filter: saturate(180%) blur(20px);
    border-bottom: 1px solid var(--border);
    padding: 8px 0 0 0;
    margin-bottom: 32px;
    position: sticky;
    top: 60px;
    z-index: 100;
}

[data-theme="dark"] .tab-navigation {
    background: rgba(28, 28, 30, 0.8);
    border-bottom-color: var(--border);
}

/* Material Design 3 Primary Navigation Tab */
.tab-button {
    position: relative;
    padding: 16px 16px 14px;
    background: transparent;
    border: none;
    border-bottom: 3px solid transparent;
    color: var(--md-sys-color-on-surface-variant);
    font-family: 'Roboto', sans-serif;
    font-weight: 500;
    font-size: 14px;
    letter-spacing: 0.1px;
    cursor: pointer;
    transition: all 200ms cubic-bezier(0.2, 0, 0, 1);
    white-space: nowrap;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    min-width: 90px;
    overflow: hidden;
}

.tab-button::before {
    content: '';
    position: absolute;
    inset: 0;
    background-color: var(--md-sys-color-on-surface);
    opacity: 0;
    transition: opacity 200ms cubic-bezier(0.2, 0, 0, 1);
}

.tab-button:hover::before {
    opacity: 0.08;
}

.tab-button.active {
    color: var(--md-sys-color-primary);
    border-bottom-color: var(--md-sys-color-primary);
}

.tab-button.active::before {
    background-color: var(--md-sys-color-primary);
    opacity: 0.12;
}

[data-theme="dark"] .tab-button.active {
    color: var(--md-sys-color-primary);
    border-bottom-color: var(--md-sys-color-primary);
}

/* Tab Content */
.tab-content {
    display: none;
}

.tab-content.active {
    display: block;
}

/* Card styles already defined in Material Design 3 section above */

/* Button and Typography styles already defined in Material Design 3 section above */

/* Material Design 3 Outlined Text Field */
.form-input, .form-select {
    border-radius: 4px;
    border: 1px solid var(--md-sys-color-outline);
    padding: 16px;
    font-family: 'Roboto', sans-serif;
    font-size: 16px;
    font-weight: 400;
    line-height: 24px;
    letter-spacing: 0.5px;
    transition: all 200ms cubic-bezier(0.2, 0, 0, 1);
    background: var(--md-sys-color-surface);
    color: var(--md-sys-color-on-surface);
}

.form-input:hover, .form-select:hover {
    border-color: var(--md-sys-color-on-surface);
}

.form-input:focus, .form-select:focus {
    outline: none;
    border-color: var(--md-sys-color-primary);
    border-width: 2px;
    padding: 15px;
}

[data-theme="dark"] .form-input,
[data-theme="dark"] .form-select {
    border-color: var(--md-sys-color-outline);
}

/* テーブルのApple風スタイル */
/* Material Design 3 Table */
table {
    border-radius: 12px;
    overflow: hidden;
    border-collapse: separate;
    border-spacing: 0;
    background: var(--md-sys-color-surface-1, var(--md-sys-color-surface));
}

table th {
    background: var(--md-sys-color-surface-2, var(--md-sys-color-surface-variant));
    color: var(--md-sys-color-on-surface);
    font-family: 'Roboto', sans-serif;
    font-weight: 500;
    font-size: 14px;
    letter-spacing: 0.1px;
    text-transform: none;
    padding: 16px;
}

table td {
    color: var(--md-sys-color-on-surface);
    font-family: 'Roboto', sans-serif;
    font-size: 14px;
    letter-spacing: 0.25px;
    padding: 16px;
}

table tr {
    position: relative;
    transition: background-color 200ms cubic-bezier(0.2, 0, 0, 1);
}

table tr:hover {
    background: color-mix(in srgb, var(--md-sys-color-on-surface) 8%, transparent);
}

/* Material Design 3 Chart Container (Elevated Card) */
.chart-container {
    border-radius: 12px;
    padding: 24px;
    background: var(--md-sys-color-surface);
    box-shadow: 0px 1px 2px 0px rgba(0, 0, 0, 0.3), 0px 1px 3px 1px rgba(0, 0, 0, 0.15);
    transition: box-shadow 200ms cubic-bezier(0.2, 0, 0, 1);
}

.chart-container:hover {
    box-shadow: 0px 1px 3px 0px rgba(0, 0, 0, 0.3), 0px 4px 8px 3px rgba(0, 0, 0, 0.15);
}

/* スムーズなアニメーション */
@keyframes fadeIn {
    from {
        opacity: 0;
        transform: translateY(20px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

/* Reduce motion対応 */
@media (prefers-reduced-motion: reduce) {
    * {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
    }
}

    </style>
</head>
<body>
    <div class="container">
        <div class="header" style="background: transparent; position: relative; padding: 16px 24px; min-height: 180px;">
            <div style="position: absolute; top: 1rem; right: 1rem; z-index: 10;">
                <div class="theme-toggle" id="themeToggle">
                    <div class="theme-option active" data-theme="light">
                        <span>☀️</span>
                        <span>ライト</span>
                    </div>
                    <div class="theme-option" data-theme="dark">
                        <span>🌙</span>
                        <span>ダーク</span>
                    </div>
                </div>
            </div>
            <h1 style="opacity: 0; height: 0; margin: 0;">しりすこPAD</h1>
        </div>

        <div id="errorArea"></div>

        <!-- SLv編集モーダル -->
        <div id="syncLevelModal" style="display: none;" class="modal" onclick="closeSyncLevelEditor()">
            <div class="modal-content" onclick="event.stopPropagation()">
                <div class="modal-header">
                    <h3>⚡ SLv 一括更新</h3>
                    <button onclick="closeSyncLevelEditor()" class="close-btn">✕</button>
                </div>

                <div class="bulk-controls">
                    <h4>一括更新</h4>
                    <div class="bulk-input-group">
                        <label for="bulkIncrease">増加値:</label>
                        <input type="number" id="bulkIncrease" value="10" min="0" max="50" class="form-input" style="width: 100px;">
                        <button onclick="applyBulkIncrease()" class="btn btn-primary">
                            全員に適用
                        </button>
                    </div>
                </div>

                <div style="margin-bottom: 1rem;">
                    <input type="text" id="playerSearch" placeholder="プレイヤー名で検索..." class="form-input" style="width: 100%;" onkeyup="filterSyncLevelList()">
                </div>

                <div id="syncLevelList" style="max-height: 400px; overflow-y: auto;">
                    <!-- プレイヤーリストがここに表示 -->
                </div>

                <div style="margin-top: 1.5rem; display: flex; gap: 1rem; justify-content: flex-end;">
                    <button onclick="applySyncLevelChanges()" class="btn btn-primary">
                        💾 変更を適用
                    </button>
                    <button onclick="closeSyncLevelEditor()" class="btn btn-outline">
                        キャンセル
                    </button>
                </div>
            </div>
        </div>

        <!-- 年月選択モーダル -->
        <div id="yearMonthModal" style="display: none;" class="modal" onclick="closeYearMonthModal()">
            <div class="modal-content" onclick="event.stopPropagation()" style="max-width: 400px;">
                <div class="modal-header">
                    <h3>📅 データの年月を選択</h3>
                    <button onclick="closeYearMonthModal()" class="close-btn">✕</button>
                </div>

                <div style="padding: 2rem 1rem;">
                    <p style="text-align: center; margin-bottom: 2rem; color: var(--text-secondary);">
                        このデータは何年何月のデータですか？
                    </p>

                    <div style="display: flex; justify-content: center; align-items: center; gap: 1rem;">
                        <div style="text-align: center;">
                            <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: var(--text-primary);">年</label>
                            <input type="number" id="yearInput" min="2020" max="2030" class="year-month-input" value="2025">
                        </div>
                        <div style="font-size: 2rem; color: var(--text-secondary); padding-top: 1.5rem;">-</div>
                        <div style="text-align: center;">
                            <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: var(--text-primary);">月</label>
                            <input type="number" id="monthInput" min="1" max="12" class="year-month-input" value="10">
                        </div>
                    </div>
                </div>

                <div style="margin-top: 1.5rem; display: flex; gap: 1rem; justify-content: flex-end;">
                    <button onclick="confirmYearMonth()" class="btn btn-primary">
                        💾 保存する
                    </button>
                    <button onclick="closeYearMonthModal()" class="btn btn-outline">
                        キャンセル
                    </button>
                </div>
            </div>
        </div>

        <!-- 月別アーカイブ保存モーダル (Phase 2) -->
        <div id="monthlyArchiveModal" style="display: none;" class="modal" onclick="closeMonthlyArchiveModal()">
            <div class="modal-content" onclick="event.stopPropagation()" style="max-width: 500px;">
                <div class="modal-header">
                    <h3>📅 月別データとして保存</h3>
                    <button onclick="closeMonthlyArchiveModal()" class="close-btn">✕</button>
                </div>

                <div style="padding: 1.5rem 1rem;">
                    <p style="text-align: center; margin-bottom: 1.5rem; color: var(--text-secondary);">
                        現在読み込まれているlatest.jsonを<br>月別データとして保存します
                    </p>

                    <div style="display: flex; justify-content: center; align-items: center; gap: 1rem;">
                        <div style="text-align: center;">
                            <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: var(--text-primary);">年</label>
                            <input type="number" id="archiveYearInput" min="2020" max="2030" class="year-month-input" value="2025">
                        </div>
                        <div style="font-size: 2rem; color: var(--text-secondary); padding-top: 1.5rem;">-</div>
                        <div style="text-align: center;">
                            <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: var(--text-primary);">月</label>
                            <input type="number" id="archiveMonthInput" min="1" max="12" class="year-month-input" value="1">
                        </div>
                    </div>

                    <div style="margin-top: 1.5rem; padding: 12px; background: var(--md-sys-color-surface-variant); border-radius: 8px; font-size: 13px; color: var(--text-secondary);">
                        💡 保存したファイルを <code>data/</code> フォルダに配置すると、<br>
                        URL経由で読み込めるようになります<br>
                        例: <code>?month=2025-01</code>
                    </div>
                </div>

                <div style="margin-top: 1rem; display: flex; gap: 1rem; justify-content: flex-end;">
                    <button onclick="confirmMonthlyArchive()" class="btn btn-primary">
                        💾 保存する
                    </button>
                    <button onclick="closeMonthlyArchiveModal()" class="btn btn-outline">
                        キャンセル
                    </button>
                </div>
            </div>
        </div>

        <!-- 使い方手順書モーダル -->
        <div id="guideModal" style="display: none;" class="modal" onclick="closeGuideModal()">
            <div class="modal-content" onclick="event.stopPropagation()" style="max-width: 700px;">
                <div class="modal-header">
                    <h3>📖 データ蓄積の使い方</h3>
                    <button onclick="closeGuideModal()" class="close-btn">✕</button>
                </div>

                <div style="padding: 1rem 0;">
                    <div class="guide-section">
                        <h4>🎯 基本的な流れ</h4>
                        <ol class="guide-steps">
                            <li>
                                <strong>JSONファイルを読み込む</strong>
                                <p>ユニオンレイドのデータ（JSONファイル）をアップロードエリアにドロップ</p>
                            </li>
                            <li>
                                <strong>年月を選択して蓄積</strong>
                                <p>「📈 データ蓄積」ボタンを押して、年月を選択（例: 2025年9月）</p>
                            </li>
                            <li>
                                <strong>次の月のデータも同様に蓄積</strong>
                                <p>10月のJSONファイルを読み込み → 「データ蓄積」で10月として保存</p>
                            </li>
                            <li>
                                <strong>プレイヤーの成長を確認</strong>
                                <p>テーブルやチャートで、各プレイヤーの月ごとの成長を確認できます</p>
                            </li>
                        </ol>
                    </div>

                    <div class="guide-section">
                        <h4>💾 データのバックアップ</h4>
                        <div class="guide-warning">
                            <p><strong>⚠️ 重要：</strong>蓄積したデータはブラウザに保存されます。ブラウザのデータを削除すると消えてしまいます。</p>
                        </div>
                        <ul class="guide-list">
                            <li><strong>エクスポート</strong>: 「📤 履歴エクスポート」で全履歴をJSONファイルとして保存</li>
                            <li><strong>インポート</strong>: 「📥 履歴インポート」で保存した履歴ファイルを復元</li>
                            <li><strong>推奨タイミング</strong>: 毎月のデータ蓄積後にエクスポートしてバックアップ</li>
                        </ul>
                    </div>

                    <div class="guide-section">
                        <h4>💡 よくある質問</h4>
                        <div class="guide-faq">
                            <div class="faq-item">
                                <strong>Q: 9月のデータを入れたのに10月として保存されてしまった</strong>
                                <p>A: データ蓄積時に年月選択画面で正しい年月（2025-09）を選択してください</p>
                            </div>
                            <div class="faq-item">
                                <strong>Q: 過去のデータが消えてしまった</strong>
                                <p>A: エクスポートしたJSONファイルがあれば、「履歴インポート」で復元できます</p>
                            </div>
                            <div class="faq-item">
                                <strong>Q: 別のPCやブラウザでも同じデータを見たい</strong>
                                <p>A: 「履歴エクスポート」でファイルを保存し、別のPC/ブラウザで「履歴インポート」してください</p>
                            </div>
                        </div>
                    </div>
                </div>

                <div style="margin-top: 1.5rem; text-align: right;">
                    <button onclick="closeGuideModal()" class="btn btn-primary">
                        ✅ 理解しました
                    </button>
                </div>
            </div>
        </div>

        <!-- エクスポートメニューモーダル -->
        <div id="exportModal" style="display: none;" class="modal" onclick="closeExportMenu()">
            <div class="modal-content" onclick="event.stopPropagation()" style="max-width: 500px;">
                <div class="modal-header">
                    <h3>📥 データエクスポート</h3>
                    <button onclick="closeExportMenu()" class="close-btn">✕</button>
                </div>

                <div style="padding: 16px 0;">
                    <p style="margin-bottom: 24px; color: var(--md-sys-color-on-surface-variant);">
                        現在のデータをエクスポートします
                    </p>

                    <div style="display: flex; flex-direction: column; gap: 12px;">
                        <button onclick="exportToCSV()" class="btn btn-primary" style="width: 100%; justify-content: flex-start; padding: 16px 24px;">
                            <span style="font-size: 24px; margin-right: 12px;">📄</span>
                            <div style="text-align: left;">
                                <div style="font-weight: 500;">CSV形式でエクスポート</div>
                                <div style="font-size: 12px; opacity: 0.7; margin-top: 4px;">Excelで開けるスプレッドシート形式</div>
                            </div>
                        </button>

                        <button onclick="exportToJSON()" class="btn btn-secondary" style="width: 100%; justify-content: flex-start; padding: 16px 24px;">
                            <span style="font-size: 24px; margin-right: 12px;">📋</span>
                            <div style="text-align: left;">
                                <div style="font-weight: 500;">JSON形式でエクスポート</div>
                                <div style="font-size: 12px; opacity: 0.7; margin-top: 4px;">プログラムで利用可能なデータ形式</div>
                            </div>
                        </button>

                        <button onclick="exportHistoryToJSON()" class="btn btn-outline" style="width: 100%; justify-content: flex-start; padding: 16px 24px;">
                            <span style="font-size: 24px; margin-right: 12px;">💾</span>
                            <div style="text-align: left;">
                                <div style="font-weight: 500;">履歴データをバックアップ</div>
                                <div style="font-size: 12px; opacity: 0.7; margin-top: 4px;">蓄積された全月のデータを保存</div>
                            </div>
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- データ比較モーダル -->
        <div id="compareModal" style="display: none;" class="modal" onclick="closeCompareModal()">
            <div class="modal-content" onclick="event.stopPropagation()" style="max-width: 800px;">
                <div class="modal-header">
                    <h3>📊 データ比較</h3>
                    <button onclick="closeCompareModal()" class="close-btn">✕</button>
                </div>

                <div style="padding: 16px 0;">
                    <div style="margin-bottom: 24px;">
                        <label style="display: block; margin-bottom: 8px; font-weight: 500;">比較する月を選択</label>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px;">
                            <div>
                                <label style="font-size: 12px; color: var(--md-sys-color-on-surface-variant);">基準月</label>
                                <select id="compareMonth1" class="form-select" style="width: 100%; margin-top: 4px;">
                                    <option value="">選択してください</option>
                                </select>
                            </div>
                            <div>
                                <label style="font-size: 12px; color: var(--md-sys-color-on-surface-variant);">比較先月</label>
                                <select id="compareMonth2" class="form-select" style="width: 100%; margin-top: 4px;">
                                    <option value="">選択してください</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <button onclick="executeCompare()" class="btn btn-primary" style="width: 100%; margin-bottom: 24px;">
                        比較実行
                    </button>

                    <div id="compareResults" style="display: none;">
                        <h4 style="margin-bottom: 16px;">比較結果</h4>
                        <div id="compareResultsContent"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- タブナビゲーション -->
        <div class="tab-navigation">
            <button class="tab-button active" data-tab="ranking" onclick="switchTab('ranking')">
                <span>📊</span> ダメージ基準スコア
            </button>
            <button class="tab-button" data-tab="slv-ranking" onclick="switchTab('slv-ranking')">
                <span>⚡</span> SLv基準スコア
            </button>
            <button class="tab-button" data-tab="characters" onclick="switchTab('characters')">
                <span>🎮</span> NIKKE編成
            </button>
            <button class="tab-button" data-tab="archive" onclick="switchTab('archive')">
                <span>📂</span> 過去データ
            </button>
            <button class="tab-button" data-tab="management" onclick="switchTab('management')">
                <span>⚙️</span> データ管理
            </button>
        </div>

        <!-- タブ1コンテンツ: ランキング & パフォーマンス分析 -->
        <div id="tab-ranking" class="tab-content active">
        <div id="results" class="results">
            <div id="statsGrid" class="stats-grid"></div>

            <!-- グラフセクション -->
            <!-- 属性別積み上げ棒グラフ -->
            <div class="card" style="margin-bottom: 24px;">
                <div style="padding: 24px;">
                    <h3 class="md-title-large" style="margin: 0 0 8px 0; color: var(--md-sys-color-on-surface);">属性別ダメージ分析</h3>
                    <p class="md-body-medium" style="color: var(--md-sys-color-on-surface-variant); margin-bottom: 24px;">
                        各プレイヤーの属性別ダメージ内訳（スコア順）
                    </p>
                    <div style="height: 400px; position: relative;">
                        <canvas id="attributeStackedChart"></canvas>
                    </div>
                </div>
            </div>

            <!-- Phase 2: フィルター＆ソート -->
            <div class="card" style="margin-bottom: 16px;">
                <h4 style="margin-bottom: 16px;">🔍 フィルター & ソート</h4>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px;">
                    <div>
                        <label style="font-size: 12px; display: block; margin-bottom: 4px;">プレイヤー検索</label>
                        <input type="text" id="playerSearchInput" placeholder="名前で検索..." class="form-input" oninput="applyFilters()">
                    </div>
                    <div>
                        <label style="font-size: 12px; display: block; margin-bottom: 4px;">最小ダメージ</label>
                        <input type="number" id="minDamageInput" placeholder="0" class="form-input" oninput="applyFilters()">
                    </div>
                    <div>
                        <label style="font-size: 12px; display: block; margin-bottom: 4px;">最小SLv</label>
                        <input type="number" id="minSlvInput" placeholder="0" class="form-input" oninput="applyFilters()">
                    </div>
                    <div>
                        <label style="font-size: 12px; display: block; margin-bottom: 4px;">ソート</label>
                        <select id="sortSelect" class="form-select" onchange="applyFilters()">
                            <option value="rank">順位順</option>
                            <option value="damage">ダメージ順</option>
                            <option value="growth">成長率順</option>
                            <option value="slv">SLv順</option>
                            <option value="name">名前順</option>
                        </select>
                    </div>
                </div>
                <div style="margin-top: 12px; display: flex; gap: 8px;">
                    <button onclick="resetFilters()" class="btn btn-text">フィルターをリセット</button>
                    <span id="filterStatus" style="margin-left: auto; font-size: 12px; color: var(--md-sys-color-on-surface-variant); align-self: center;"></span>
                </div>
            </div>

            <div class="data-table">
                <table id="resultsTable">
                    <thead>
                        <tr>
                            <th style="cursor: pointer;" onclick="sortBy('rank')">
                                順位 <span id="sort-rank"></span>
                            </th>
                            <th style="cursor: pointer;" onclick="sortBy('name')">
                                プレイヤー <span id="sort-name"></span>
                            </th>
                            <th style="cursor: pointer;" onclick="sortBy('damage')">
                                ダメージ <span id="sort-damage"></span>
                            </th>
                            <th style="cursor: pointer;" onclick="sortBy('slv')">
                                SLv <span id="sort-slv"></span>
                            </th>
                            <th style="cursor: pointer;" onclick="sortBy('growth')">
                                成長率 <span id="sort-growth"></span>
                            </th>
                        </tr>
                    </thead>
                    <tbody id="tableBody">
                    </tbody>
                </table>
            </div>
        </div>
    </div>
        </div>
        <!-- /タブ1 -->

        <!-- タブ2: SLv基準スコア -->
        <div id="tab-slv-ranking" class="tab-content">
            <!-- SLv vs スコア分析グラフ -->
            <div class="card" style="margin-bottom: 24px;">
                <div style="padding: 24px;">
                    <h3 class="md-title-large" style="margin: 0 0 8px 0; color: var(--md-sys-color-on-surface);">⚡ SLv vs スコア分析</h3>
                    <p class="md-body-medium" style="color: var(--md-sys-color-on-surface-variant); margin-bottom: 24px;">
                        Sync Levelに対するパフォーマンス比較
                    </p>
                    <div style="height: 400px; position: relative;">
                        <canvas id="slvComparisonChart"></canvas>
                    </div>
                </div>
            </div>

            <!-- ダメージ/SLv 効率ランキング -->
            <div class="card" style="margin-bottom: 16px;">
                <h3 class="md-title-large" style="margin: 0 0 8px 0; color: var(--md-sys-color-on-surface);">🎯 育成効率ランキング</h3>
                <p class="md-body-medium" style="color: var(--md-sys-color-on-surface-variant); margin-bottom: 16px;">
                    SLv1あたりのダメージ効率（育成・戦略の最適化指標）
                </p>
            </div>

            <div class="data-table">
                <table id="slvEfficiencyTable">
                    <thead>
                        <tr>
                            <th style="cursor: pointer;" onclick="sortSlvEfficiency('rank')">
                                順位 <span id="slv-sort-rank"></span>
                            </th>
                            <th style="cursor: pointer;" onclick="sortSlvEfficiency('name')">
                                プレイヤー <span id="slv-sort-name"></span>
                            </th>
                            <th style="cursor: pointer;" onclick="sortSlvEfficiency('efficiency')">
                                ダメージ/SLv <span id="slv-sort-efficiency">▼</span>
                            </th>
                            <th style="cursor: pointer;" onclick="sortSlvEfficiency('damage')">
                                総ダメージ <span id="slv-sort-damage"></span>
                            </th>
                            <th style="cursor: pointer;" onclick="sortSlvEfficiency('slv')">
                                SLv <span id="slv-sort-slv"></span>
                            </th>
                        </tr>
                    </thead>
                    <tbody id="slvEfficiencyTableBody">
                    </tbody>
                </table>
            </div>
        </div>
        <!-- /タブ2 -->

        <!-- タブ3: キャラクター使用率分析 -->
        <div id="tab-characters" class="tab-content">
            <!-- 属性選択タブ -->
            <div class="card" style="margin-bottom: 24px;">
                <div style="padding: 16px;">
                    <h3 style="margin: 0 0 12px 0; color: var(--md-sys-color-on-surface);">属性別フィルタ</h3>
                    <div class="attribute-tabs" style="display: flex; gap: 8px; flex-wrap: wrap;">
                        <button class="attribute-tab-btn active" data-attribute="ALL" onclick="switchAttributeTab('ALL')">
                            全属性統合
                        </button>
                        <button class="attribute-tab-btn" data-attribute="FIRE" onclick="switchAttributeTab('FIRE')">
                            <img src="./属性アイコン/灼熱.png" style="width: 20px; height: 20px; vertical-align: middle; margin-right: 4px;">
                            灼熱
                        </button>
                        <button class="attribute-tab-btn" data-attribute="WATER" onclick="switchAttributeTab('WATER')">
                            <img src="./属性アイコン/水冷.png" style="width: 20px; height: 20px; vertical-align: middle; margin-right: 4px;">
                            水冷
                        </button>
                        <button class="attribute-tab-btn" data-attribute="ELECTRIC" onclick="switchAttributeTab('ELECTRIC')">
                            <img src="./属性アイコン/電撃.png" style="width: 20px; height: 20px; vertical-align: middle; margin-right: 4px;">
                            電撃
                        </button>
                        <button class="attribute-tab-btn" data-attribute="IRON" onclick="switchAttributeTab('IRON')">
                            <img src="./属性アイコン/鉄甲.png" style="width: 20px; height: 20px; vertical-align: middle; margin-right: 4px;">
                            鉄甲
                        </button>
                        <button class="attribute-tab-btn" data-attribute="WIND" onclick="switchAttributeTab('WIND')">
                            <img src="./属性アイコン/風圧.png" style="width: 20px; height: 20px; vertical-align: middle; margin-right: 4px;">
                            風圧
                        </button>
                    </div>
                </div>
            </div>

            <!-- 編成一覧 -->
            <div class="card">
                <h3 style="margin-bottom: 16px;">🎯 編成一覧</h3>
                <p style="color: var(--md-sys-color-on-surface-variant); margin-bottom: 16px; font-size: 14px;">
                    各ボスに対する攻撃編成とダメージスコア
                </p>
                <div id="teamCompositionsContainer">
                    <p style="color: var(--md-sys-color-on-surface-variant); text-align: center; padding: 32px;">
                        データを読み込むと表示されます
                    </p>
                </div>
            </div>
        </div>

        <!-- タブ: 過去データ閲覧 -->
        <div id="tab-archive" class="tab-content">
            <div class="card" style="margin-bottom: 24px;">
                <h3 style="margin-bottom: 16px; display: flex; align-items: center; gap: 8px;">
                    📂 過去データ閲覧
                </h3>
                <p style="color: var(--md-sys-color-on-surface-variant); margin-bottom: 24px;">
                    保存された過去の月別データを選択して閲覧できます
                </p>

                <!-- 月選択ドロップダウン -->
                <div style="margin-bottom: 24px;">
                    <label style="display: block; margin-bottom: 8px; font-weight: 500; color: var(--md-sys-color-on-surface);">
                        📅 閲覧する月を選択
                    </label>
                    <select id="archiveMonthSelect"
                            style="width: 100%; padding: 12px; border-radius: 8px; border: 1px solid var(--md-sys-color-outline); background: var(--md-sys-color-surface); color: var(--md-sys-color-on-surface); font-size: 16px; font-family: 'Roboto', sans-serif;">
                        <option value="">月を選択してください</option>
                    </select>
                </div>

                <!-- 読み込みボタン -->
                <div style="display: flex; gap: 12px; flex-wrap: wrap;">
                    <button onclick="loadArchiveData()" class="btn btn-primary">
                        📥 選択した月のデータを読み込む
                    </button>
                    <button onclick="backToLatest()" class="btn btn-outline">
                        🔄 最新データに戻る
                    </button>
                </div>

                <!-- 読み込み状態表示 -->
                <div id="archiveStatus" style="margin-top: 16px; padding: 12px; border-radius: 8px; display: none;">
                </div>
            </div>

            <!-- 現在表示中のデータ情報 -->
            <div class="card">
                <h3 style="margin-bottom: 16px;">📊 現在表示中のデータ</h3>
                <div id="currentDataInfo" style="padding: 16px; background: var(--md-sys-color-surface-variant); border-radius: 8px;">
                    <p style="color: var(--md-sys-color-on-surface-variant);">データが読み込まれていません</p>
                </div>
            </div>
        </div>

        <!-- タブ3: データ管理 -->
        <div id="tab-management" class="tab-content">
            <!-- ファイルアップロード -->
            <div class="card" style="margin-bottom: 24px;">
                <h3 style="margin-bottom: 16px;">📁 データアップロード</h3>
                <div class="upload-area" onclick="document.getElementById('fileInput').click()">
                    <input type="file" id="fileInput" accept=".json" />
                    <h3>📁 JSONファイルをアップロード</h3>
                    <p>ファイルをここにドラッグ&ドロップするか、クリックして選択してください</p>
                    <small>対応形式: .json (最大10MB)</small>
                </div>

                <!-- Union順位入力 -->
                <div style="margin-top: 16px; padding: 16px; background: var(--md-sys-color-surface-variant); border-radius: 8px;">
                    <h4 style="margin: 0 0 12px 0; color: var(--md-sys-color-on-surface); font-size: 14px;">
                        Union順位 (オプション)
                    </h4>
                    <div style="display: flex; gap: 12px; align-items: center; flex-wrap: wrap;">
                        <label style="color: var(--md-sys-color-on-surface-variant); font-size: 14px;">
                            順位 (%):
                        </label>
                        <input type="number"
                               id="unionRankInput"
                               step="0.1"
                               min="0"
                               max="100"
                               placeholder="例: 1.5"
                               style="padding: 8px 12px; border-radius: 4px; border: 1px solid var(--md-sys-color-outline); background: var(--md-sys-color-surface); color: var(--md-sys-color-on-surface); font-size: 14px; width: 120px;">
                        <small style="color: var(--md-sys-color-on-surface-variant); font-size: 12px;">
                            データ蓄積時にUnion順位も保存されます
                        </small>
                    </div>
                </div>
            </div>


            <!-- データ蓄積・履歴管理 -->
            <div class="card" style="margin-bottom: 24px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; flex-wrap: wrap; gap: 8px;">
                    <h3 style="margin: 0;">📊 データ蓄積・履歴管理</h3>
                    <a href="javascript:void(0)" onclick="showGuideModal()" style="color: var(--md-sys-color-primary); text-decoration: none; font-size: 14px; display: flex; align-items: center; gap: 4px;">
                        <span>❓</span> 使い方を見る
                    </a>
                </div>

                <div style="display: flex; gap: 12px; margin-bottom: 16px; flex-wrap: wrap;">
                    <button onclick="accumulateData()" class="btn btn-primary">
                        📈 現在のデータを蓄積
                    </button>
                    <button onclick="exportMonthlyArchive()" class="btn btn-primary">
                        📅 月別データとして保存
                    </button>
                    <button onclick="exportSharedHistory()" class="btn btn-primary">
                        🔄 共有履歴を生成
                    </button>
                    <button onclick="exportHistoryToJSON()" class="btn btn-outline">
                        💾 履歴をバックアップ
                    </button>
                    <button onclick="importHistoryFromJSON()" class="btn btn-outline">
                        📂 履歴を復元
                    </button>
                </div>

                <!-- データ蓄積状況サマリー -->
                <div style="padding: 16px; background: var(--md-sys-color-secondary-container); border-radius: 8px; margin-bottom: 16px;">
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px;">
                        <div>
                            <div style="font-size: 12px; color: var(--md-sys-color-on-secondary-container); opacity: 0.8; margin-bottom: 4px;">
                                蓄積データ数
                            </div>
                            <div style="font-size: 24px; font-weight: 600; color: var(--md-sys-color-on-secondary-container);">
                                <span id="historyCount">0</span>ヶ月
                            </div>
                        </div>
                        <div>
                            <div style="font-size: 12px; color: var(--md-sys-color-on-secondary-container); opacity: 0.8; margin-bottom: 4px;">
                                保存期間
                            </div>
                            <div style="font-size: 16px; font-weight: 500; color: var(--md-sys-color-on-secondary-container);" id="dataRangeDisplay">
                                データなし
                            </div>
                        </div>
                    </div>
                </div>

                <div id="historyList" style="margin-top: 16px;">
                    <h4 style="font-size: 14px; margin-bottom: 12px; color: var(--md-sys-color-on-surface-variant);">
                        月別データ一覧
                    </h4>
                    <div id="historyItems" style="display: flex; flex-direction: column; gap: 8px;">
                        <p style="color: var(--md-sys-color-on-surface-variant); text-align: center; padding: 24px; font-size: 14px;">
                            まだデータが蓄積されていません
                        </p>
                    </div>
                </div>
            </div>

            <!-- ストレージ情報 -->
            <div class="card">
                <h3 style="margin-bottom: 16px;">💾 ストレージ情報</h3>
                <div id="storageInfoBox" style="background: var(--md-sys-color-surface-variant); padding: 16px; border-radius: 8px;">
                    <p style="margin: 0; font-size: 14px; color: var(--md-sys-color-on-surface-variant);">
                        データを読み込むと表示されます
                    </p>
                </div>
            </div>

            <!-- テーマカラー選択 -->
            <div class="card">
                <h3 style="margin-bottom: 16px;">🎨 テーマカラー設定</h3>
                <p style="color: var(--md-sys-color-on-surface-variant); margin-bottom: 20px; font-size: 14px;">
                    お好みのテーマカラーを選択してください
                </p>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 12px;">
                    <button onclick="changeColorTheme('purple')" class="theme-color-btn" data-theme="purple" style="background: #6750A4;">
                        <span style="font-size: 20px;">💜</span>
                        <span style="font-size: 14px; font-weight: 500;">パープル</span>
                    </button>
                    <button onclick="changeColorTheme('blue')" class="theme-color-btn" data-theme="blue" style="background: #1976D2;">
                        <span style="font-size: 20px;">💙</span>
                        <span style="font-size: 14px; font-weight: 500;">ブルー</span>
                    </button>
                    <button onclick="changeColorTheme('teal')" class="theme-color-btn" data-theme="teal" style="background: #00897B;">
                        <span style="font-size: 20px;">💚</span>
                        <span style="font-size: 14px; font-weight: 500;">ティール</span>
                    </button>
                    <button onclick="changeColorTheme('green')" class="theme-color-btn" data-theme="green" style="background: #388E3C;">
                        <span style="font-size: 20px;">🌿</span>
                        <span style="font-size: 14px; font-weight: 500;">グリーン</span>
                    </button>
                    <button onclick="changeColorTheme('red')" class="theme-color-btn" data-theme="red" style="background: #D32F2F;">
                        <span style="font-size: 20px;">❤️</span>
                        <span style="font-size: 14px; font-weight: 500;">レッド</span>
                    </button>
                    <button onclick="changeColorTheme('orange')" class="theme-color-btn" data-theme="orange" style="background: #F57C00;">
                        <span style="font-size: 20px;">🧡</span>
                        <span style="font-size: 14px; font-weight: 500;">オレンジ</span>
                    </button>
                </div>
            </div>

            <!-- デバッグ情報 -->
            <div id="debugInfo" style="display: none;" class="card">
                <h4 style="margin-bottom: 16px;">🔍 デバッグ情報</h4>
                <div id="debugContent" style="font-family: 'Roboto Mono', Consolas, monospace; font-size: 12px; background: var(--md-sys-color-surface-variant); padding: 16px; border-radius: 8px; overflow-x: auto;">
                    ブラウザのデベロッパーツール（F12）のコンソールも確認してください
                </div>
            </div>
        </div>
    </div>

    <!-- 個人詳細モーダル -->
    <div id="playerModal" class="player-modal" style="display: none;">
        <div class="player-modal-content">
            <div class="player-modal-header">
                <h2 id="playerModalTitle">プレイヤー詳細</h2>
                <button class="close-btn" onclick="hidePlayerDetails()">&times;</button>
            </div>
            <div class="player-modal-body">
                <!-- ボス別攻撃詳細セクション -->
                <div class="player-attacks-section">
                    <h3>ボス別攻撃詳細</h3>
                    <div id="playerAttacksContainer">
                        <!-- 動的に生成される -->
                    </div>
                </div>

                <div class="player-history-section">
                    <h3>月別成績推移</h3>
                    <div class="player-history-table-container">
                        <table id="playerHistoryTable" class="player-history-table">
                            <thead>
                                <tr>
                                    <th>月</th>
                                    <th>ダメージ</th>
                                    <th>ダメージ変化</th>
                                    <th>シンクロレベル</th>
                                    <th>SLv変化</th>
                                </tr>
                            </thead>
                            <tbody id="playerHistoryTableBody">
                            </tbody>
                        </table>
                    </div>
                </div>
                <div class="player-charts-section">
                    <div class="player-chart-container">
                        <h4>ダメージ推移</h4>
                        <canvas id="playerDamageChart"></canvas>
                    </div>
                    <div class="player-chart-container">
                        <h4>シンクロレベル推移</h4>
                        <canvas id="playerSyncChart"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- ユニオン順位推移モーダル -->
    <div id="unionRankModal" class="player-modal" style="display: none;">
        <div class="player-modal-content">
            <div class="player-modal-header">
                <h2>🏆 ユニオン順位推移</h2>
                <button class="close-btn" onclick="hideUnionRankTrend()">&times;</button>
            </div>
            <div class="player-modal-body">
                <div class="player-history-section">
                    <h3>月別順位履歴</h3>
                    <div class="player-history-table-container">
                        <table id="unionRankHistoryTable" class="player-history-table">
                            <thead>
                                <tr>
                                    <th>月</th>
                                    <th>順位</th>
                                    <th>順位変化</th>
                                    <th>総ダメージ</th>
                                </tr>
                            </thead>
                            <tbody id="unionRankHistoryTableBody">
                            </tbody>
                        </table>
                    </div>
                </div>
                <div class="player-charts-section" style="grid-template-columns: 1fr;">
                    <div class="player-chart-container">
                        <h4>ユニオン順位推移 (% - 小さいほど良い順位)</h4>
                        <canvas id="unionRankChart"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ボス属性マッピングシステム
        const BOSS_ATTRIBUTES = {
            'H.S.T.A.': {
                name: 'Hestia',
                nameJP: '灼熱ヘスティア',
                attribute: 'FIRE',
                attributeJP: '灼熱',
                color: '#FF3B30',
                icon: './属性アイコン/灼熱.png'
            },
            'P.S.I.D.': {
                name: 'Poseidon',
                nameJP: '水冷ポセイドン',
                attribute: 'WATER',
                attributeJP: '水冷',
                color: '#007AFF',
                icon: './属性アイコン/水冷.png'
            },
            'Z.E.U.S.': {
                name: 'Zeus',
                nameJP: '電撃ゼウス',
                attribute: 'ELECTRIC',
                attributeJP: '電撃',
                color: '#8E44AD',
                icon: './属性アイコン/電撃.png'
            },
            'D.M.T.R.': {
                name: 'Demeter',
                nameJP: '鉄甲デメテル',
                attribute: 'IRON',
                attributeJP: '鉄甲',
                color: '#FF9500',
                icon: './属性アイコン/鉄甲.png'
            },
            'A.N.M.I.': {
                name: 'Anemoi',
                nameJP: '風圧アネモイ',
                attribute: 'WIND',
                attributeJP: '風圧',
                color: '#34C759',
                icon: './属性アイコン/風圧.png'
            }
        };

        // ユーティリティ関数
        function getBossAttribute(bossCode) {
            return BOSS_ATTRIBUTES[bossCode] || null;
        }

        function getAttributeColor(bossCode) {
            const attr = BOSS_ATTRIBUTES[bossCode];
            return attr ? attr.color : '#666666';
        }

        // グローバル変数
        let rawData = null;
        let processedData = [];
        let filteredData = [];
        let historyData = {};
        let growthData = [];
        let currentUnionRank = null; // 現在のユニオン順位（％）
        let unionRankHistory = {}; // ユニオン順位履歴
        let isAutoExtracting = false; // 自動抽出中フラグ

        // キャラクター使用率（属性別）
        let characterUsageByAttribute = {
            ALL: {},
            FIRE: {},
            WATER: {},
            ELECTRIC: {},
            IRON: {},
            WIND: {}
        };
        let currentAttribute = 'ALL'; // 現在選択中の属性

        // テーマ管理
        let currentTheme = localStorage.getItem('nikke-analytics-theme') || 'light';

        function initializeTheme() {
            document.body.setAttribute('data-theme', currentTheme);
            document.documentElement.setAttribute('data-theme', currentTheme);
            updateThemeToggle();
        }

        function toggleTheme(theme) {
            currentTheme = theme;
            document.body.setAttribute('data-theme', theme);
            document.documentElement.setAttribute('data-theme', theme);
            localStorage.setItem('nikke-analytics-theme', theme);
            updateThemeToggle();

            // チャートが存在する場合は再描画
            if (window.myChart && processedData.length > 0) {
                updateChart();
            }
        }

        function updateThemeToggle() {
            const options = document.querySelectorAll('.theme-option');
            options.forEach(option => {
                if (option.getAttribute('data-theme') === currentTheme) {
                    option.classList.add('active');
                } else {
                    option.classList.remove('active');
                }
            });
        }

        // Material Design 3 Ripple Effect
        function createRipple(event) {
            const button = event.currentTarget;
            const ripple = document.createElement('span');
            const rect = button.getBoundingClientRect();
            const size = Math.max(rect.width, rect.height);
            const x = event.clientX - rect.left - size / 2;
            const y = event.clientY - rect.top - size / 2;

            ripple.style.width = ripple.style.height = size + 'px';
            ripple.style.left = x + 'px';
            ripple.style.top = y + 'px';
            ripple.classList.add('md-ripple');

            const existingRipple = button.querySelector('.md-ripple');
            if (existingRipple) {
                existingRipple.remove();
            }

            button.appendChild(ripple);

            setTimeout(() => {
                ripple.remove();
            }, 600);
        }

        function initializeRippleEffect() {
            // Add ripple styles dynamically
            const style = document.createElement('style');
            style.textContent = `
                .md-ripple {
                    position: absolute;
                    border-radius: 50%;
                    background-color: currentColor;
                    opacity: 0.3;
                    pointer-events: none;
                    animation: md-ripple-animation 600ms cubic-bezier(0.4, 0, 0.2, 1);
                    transform: scale(0);
                }

                @keyframes md-ripple-animation {
                    to {
                        transform: scale(4);
                        opacity: 0;
                    }
                }

                .btn, .md-fab, .md-icon-button, .tab-button {
                    position: relative;
                    overflow: hidden;
                }
            `;
            document.head.appendChild(style);

            // Add ripple to all interactive elements
            const rippleElements = document.querySelectorAll('.btn, .md-fab, .md-icon-button, .tab-button');
            rippleElements.forEach(element => {
                element.addEventListener('click', createRipple);
            });
        }

        // ページ読み込み時にテーマを初期化
        document.addEventListener('DOMContentLoaded', function() {
            initializeTheme();
            initializeRippleEffect();

            // テーマ切り替えイベントリスナー
            document.querySelectorAll('.theme-option').forEach(option => {
                option.addEventListener('click', function() {
                    const theme = this.getAttribute('data-theme');
                    toggleTheme(theme);
                });
            });

            // 履歴データを読み込み
            historyData = loadFromLocalStorage();

            // 拡張機能からの自動抽出開始イベントを監視
            document.addEventListener('nikke-auto-extract-start', function() {
                isAutoExtracting = true;
                console.log('🔒 自動抽出開始: モーダルの外側クリックを無効化');
            });

            // 拡張機能からの自動抽出終了イベントを監視
            document.addEventListener('nikke-auto-extract-end', function() {
                isAutoExtracting = false;
                console.log('🔓 自動抽出終了: モーダルの外側クリックを有効化');
            });
        });

        // ファイルアップロード処理
        const fileInput = document.getElementById('fileInput');
        const uploadArea = document.querySelector('.upload-area');
        const errorArea = document.getElementById('errorArea');
        const results = document.getElementById('results');

        // ページ全体でのドラッグ&ドロップのデフォルト動作を防ぐ
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            document.body.addEventListener(eventName, (e) => {
                e.preventDefault();
                e.stopPropagation();
            }, false);
        });

        fileInput.addEventListener('change', handleFile);

        uploadArea.addEventListener('dragenter', (e) => {
            e.preventDefault();
            e.stopPropagation();
            console.log('📥 ドラッグエンター');
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
        });

        uploadArea.addEventListener('dragleave', (e) => {
            e.preventDefault();
            e.stopPropagation();
            console.log('📤 ドラッグリーブ');
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            e.stopPropagation();
            console.log('🎯 ドロップイベント発火！');
            uploadArea.classList.remove('dragover');

            const files = e.dataTransfer.files;
            console.log('📁 ドロップされたファイル数:', files.length);

            if (files.length > 0) {
                console.log('📄 ファイル名:', files[0].name);
                console.log('📄 ファイルタイプ:', files[0].type);
                console.log('📄 ファイルサイズ:', files[0].size);
                handleFileObject(files[0]);
            } else {
                console.error('❌ ファイルが見つかりません');
            }
        });

        function handleFile(event) {
            handleFileObject(event.target.files[0]);
        }

        function handleFileObject(file) {
            console.log('ファイル処理開始:', file.name, file.type, file.size);

            if (!file) {
                showError('ファイルが選択されていません');
                return;
            }

            if (!file.name.endsWith('.json') && !file.type.includes('json')) {
                console.warn('JSONファイルではない可能性があります:', file.type);
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    console.log('ファイル読み込み完了');
                    let content = e.target.result;

                    // BOM（Byte Order Mark）を削除
                    if (content.charCodeAt(0) === 0xFEFF) {
                        content = content.substring(1);
                        console.log('BOMを削除しました');
                    }

                    console.log('ファイル内容（最初の100文字）:', content.substring(0, 100));

                    rawData = JSON.parse(content);
                    console.log('JSON解析完了:', rawData);

                    processData();
                    showResults();
                } catch (error) {
                    console.error('エラー詳細:', error);
                    console.error('ファイル先頭の文字コード:', content.substring(0, 10).split('').map(c => c.charCodeAt(0)));
                    showError('JSONファイルの解析に失敗しました: ' + error.message);
                }
            };

            reader.onerror = function() {
                showError('ファイルの読み込みに失敗しました');
            };

            reader.readAsText(file, 'UTF-8');
        }

        function showError(message) {
            errorArea.innerHTML = `<div class="error">${message}</div>`;
        }

        function processData() {
            console.log('データ処理開始');

            if (!rawData) {
                showError('データがありません');
                return;
            }

            console.log('rawData構造:', Object.keys(rawData));

            // metadataの検証とバージョンチェック（v2.2+対応）
            if (rawData.metadata) {
                console.log('=== メタデータ検出 ===');
                console.log('バージョン:', rawData.metadata.version);
                console.log('詳細攻撃データ:', rawData.metadata.hasDetailedAttacks);
                console.log('抽出日時:', rawData.metadata.extractedAt);
                console.log('プレイヤー数:', rawData.metadata.playerCount);
                console.log('総ダメージ:', rawData.metadata.totalDamage);

                // バージョン警告
                const version = parseFloat(rawData.metadata.version);
                if (version < 2.0) {
                    console.warn('⚠️ 古いバージョンのデータです。一部の機能が利用できない可能性があります。');
                } else if (version >= 2.2) {
                    console.log('✅ 最新バージョンのデータ（v2.2+）- 全機能利用可能');
                }

                // ユニオン順位の自動読み込み（Phase 1: latest.jsonからのunionRank対応）
                if (rawData.metadata.unionRank !== undefined && rawData.metadata.unionRank !== null) {
                    currentUnionRank = rawData.metadata.unionRank;
                    console.log('✅ latest.jsonからユニオン順位を読み込みました:', currentUnionRank);
                    showNotification(`ユニオン順位を読み込みました: ${currentUnionRank}%`, 'success');

                    // localStorageに保存
                    localStorage.setItem('nikke-current-union-rank', currentUnionRank.toString());

                    // 履歴にも反映
                    const currentMonth = getCurrentMonth();
                    if (!unionRankHistory[currentMonth]) {
                        unionRankHistory[currentMonth] = {};
                    }
                    unionRankHistory[currentMonth] = {
                        rank: currentUnionRank,
                        totalDamage: rawData.metadata.totalDamage || 0,
                        date: rawData.metadata.extractedAt ? rawData.metadata.extractedAt.slice(0, 10) : new Date().toISOString().slice(0, 10)
                    };
                    localStorage.setItem('nikke-union-rank-history', JSON.stringify(unionRankHistory));

                    console.log('✅ ユニオン順位履歴を更新しました:', currentMonth, unionRankHistory[currentMonth]);
                }
            }

            // v8.0形式（直接playersの配列）かv5.0形式（raidData.playersの構造）かを判定
            let players = [];
            let unionMembers = [];

            if (rawData.players && Array.isArray(rawData.players)) {
                console.log('v8.0形式のデータを検出');
                players = rawData.players;
                unionMembers = rawData.unionMembers || [];
            } else if (rawData.raidData && rawData.raidData.players) {
                console.log('v5.0形式のデータを検出');
                players = rawData.raidData.players;
                unionMembers = rawData.unionMembers || [];
            } else {
                showError('不明なデータ形式です。v8.0形式またはv5.0形式のJSONファイルが必要です');
                return;
            }

            if (!Array.isArray(players) || players.length === 0) {
                showError('プレイヤーデータが見つからないか空です');
                return;
            }

            console.log('プレイヤー数:', players.length);
            console.log('Union members:', unionMembers);

            // 攻撃詳細データの検証
            console.log('=== 攻撃詳細データ検証 ===');
            players.forEach((player, index) => {
                if (player.attacks && Array.isArray(player.attacks) && player.attacks.length > 0) {
                    console.log(`${player.player}: ${player.attacks.length}件の攻撃詳細`);

                    player.attacks.forEach((attack, attackIndex) => {
                        // 必須フィールドチェック
                        if (!attack.bossType) {
                            console.warn(`⚠️ ${player.player}の攻撃${attackIndex + 1}にbossTypeがありません`);
                        }
                        if (!attack.damage || attack.damage === 0) {
                            console.warn(`⚠️ ${player.player}の攻撃${attackIndex + 1}のダメージが0または未設定です`);
                        }

                        // キャラクター画像URLの検証
                        if (attack.characters && Array.isArray(attack.characters)) {
                            const validCharacters = [];
                            attack.characters.forEach((url, urlIndex) => {
                                // 文字列で、空でなければ有効とする（相対パスとHTTP URLの両方に対応）
                                if (typeof url === 'string' && url.trim() !== '') {
                                    validCharacters.push(url);
                                } else {
                                    console.warn(`⚠️ 無効な画像URL: ${player.player}の攻撃${attackIndex + 1}、キャラ${urlIndex + 1}: ${url}`);
                                }
                            });
                            attack.characters = validCharacters;
                        }
                    });
                }
            });

            try {
                // 前月のデータを取得してSLvを引き継ぐ
                const currentMonth = getCurrentMonth();
                const allHistoryMonths = Object.keys(historyData).sort();
                const previousMonth = allHistoryMonths[allHistoryMonths.length - 1]; // 最新の履歴月
                let previousMonthData = null;

                console.log('=== SLv引き継ぎ処理 ===');
                console.log('現在の月:', currentMonth);
                console.log('履歴の月一覧:', allHistoryMonths);
                console.log('前月:', previousMonth);

                if (previousMonth && historyData[previousMonth] && Array.isArray(historyData[previousMonth])) {
                    const monthDataArray = historyData[previousMonth];
                    previousMonthData = monthDataArray[monthDataArray.length - 1]; // 最新のデータ
                    console.log('前月データを検出:', previousMonth, '- プレイヤー数:', previousMonthData?.players?.length);
                    if (previousMonthData?.players) {
                        console.log('前月の最初の3名:', previousMonthData.players.slice(0, 3).map(p => `${p.player}: SLv ${p.syncLevel}`));
                    }
                }

                processedData = players.map((player, index) => {
                    const playerName = player.player || `Player${index + 1}`;
                    const damage = player.totalDamage || player.damage || 0;
                    let syncLevel = player.syncLevel || 0;
                    const attacks = player.attacks || [];

                    console.log(`プレイヤー ${playerName}: JSONのSLv=${player.syncLevel || 0}`);

                    // 前月のデータからSLvを引き継ぐ
                    if (previousMonthData && previousMonthData.players) {
                        const previousPlayer = previousMonthData.players.find(p => p.player === playerName);
                        console.log(`  前月データ検索: ${previousPlayer ? 'あり' : 'なし'}`, previousPlayer ? `SLv=${previousPlayer.syncLevel}` : '');

                        // JSONにSLvがない、または0の場合に前月から引き継ぐ
                        if (previousPlayer && previousPlayer.syncLevel) {
                            if (!player.syncLevel || player.syncLevel === 0) {
                                syncLevel = previousPlayer.syncLevel;
                                console.log(`  ✅ ${playerName}のSLvを前月から引き継ぎ: ${syncLevel}`);
                            } else {
                                console.log(`  ℹ️ ${playerName}は既にSLvあり: ${player.syncLevel}`);
                            }
                        }
                    }

                    if (!playerName || typeof damage !== 'number' || typeof syncLevel !== 'number') {
                        console.warn('不正なプレイヤーデータ:', player);
                    }

                    return {
                        id: player.id || `player_${index}`,
                        player: playerName,
                        damage: damage,
                        syncLevel: syncLevel,
                        attacks: attacks,
                        isUnion: unionMembers.includes(playerName),
                        originalData: player
                    };
                }).sort((a, b) => b.damage - a.damage);

                processedData.forEach((player, index) => {
                    player.rank = index + 1;
                });

                filteredData = [...processedData];
                console.log('データ処理完了:', processedData.length, 'プレイヤー');

                // 履歴データを処理
                processHistoryData();

                // 編成一覧分析を実行
                analyzeTeamCompositions();
                generateGrowthData();

            } catch (error) {
                console.error('データ処理エラー:', error);
                showError('データ処理中にエラーが発生しました: ' + error.message);
            }
        }

        // 履歴データ処理関数
        function processHistoryData() {
            // ローカルストレージから履歴データを読み込む（既存のデータを保持）
            historyData = loadFromLocalStorage();

            // JSONファイルに履歴データが含まれている場合はマージ
            if (rawData.historyData && typeof rawData.historyData === 'object') {
                // JSONファイルの履歴データをマージ
                Object.keys(rawData.historyData).forEach(month => {
                    if (!historyData[month]) {
                        historyData[month] = rawData.historyData[month];
                    }
                });
                console.log('履歴データ読み込み:', Object.keys(historyData).length, '個の月');
                console.log('履歴データの詳細:', historyData);
                Object.keys(historyData).forEach(month => {
                    const monthData = historyData[month];
                    console.log(`月: ${month}, データ:`, monthData);
                    if (Array.isArray(monthData) && monthData[0]) {
                        console.log(`${month}のプレイヤー数:`, monthData[0].players?.length);
                    }
                });
            } else {
                console.log('ローカルストレージから履歴データを読み込みました:', Object.keys(historyData).length, '個の月');
            }
        }

        // 成長データ生成関数
        function generateGrowthData() {
            growthData = [];
            const currentMonth = getCurrentMonth();
            const allMonths = [...new Set(Object.keys(historyData).concat(currentMonth))].sort();
            const playerGrowthMap = new Map();

            console.log('=== 成長データ生成開始 ===');
            console.log('現在の月:', currentMonth);
            console.log('historyDataの内容:', historyData);
            console.log('historyDataのキー:', Object.keys(historyData));
            console.log('全ての月:', allMonths);
            console.log('processedData:', processedData);

            allMonths.forEach(month => {
                let monthData;
                if (month === currentMonth) {
                    monthData = { players: processedData };
                    console.log(`現在の月 ${month}:`, monthData.players.length, 'プレイヤー');
                } else {
                    // 履歴データは配列形式なので、最新のデータ（最後の要素）を取得
                    console.log(`${month}の履歴データ配列:`, historyData[month]);
                    if (historyData[month] && Array.isArray(historyData[month])) {
                        console.log(`${month}の履歴データ配列の長さ:`, historyData[month].length);
                        const latestIndex = historyData[month].length - 1;
                        console.log(`${month}の最新データ[${latestIndex}]:`, historyData[month][latestIndex]);
                        if (historyData[month].length > 1) {
                            console.log(`情報: ${month}には複数のデータが存在します:`, historyData[month].length, '個（最新のデータを使用）');
                        }
                    }
                    // 配列の最後の要素（最新のデータ）を取得
                    monthData = historyData[month] && Array.isArray(historyData[month]) && historyData[month].length > 0 ?
                        historyData[month][historyData[month].length - 1] : null;
                    console.log(`履歴の月 ${month}:`, monthData ? monthData.players?.length : 'データなし', 'プレイヤー');
                }

                if (monthData && monthData.players) {
                    console.log(`${month}のプレイヤーデータを処理中...`);
                    monthData.players.forEach(player => {
                        if (!playerGrowthMap.has(player.player)) {
                            playerGrowthMap.set(player.player, {
                                player: player.player,
                                monthlyData: []
                            });
                        }

                        const growthEntry = playerGrowthMap.get(player.player);
                        growthEntry.monthlyData.push({
                            month: month,
                            damage: player.damage,
                            syncLevel: player.syncLevel
                        });
                    });
                }
            });

            growthData = Array.from(playerGrowthMap.values());
            console.log('成長データ生成:', growthData.length, 'プレイヤー');
        }

        // 現在の月を取得（データから、なければ現在日付から）
        function getCurrentMonth() {
            if (rawData.raidData && rawData.raidData.month) {
                return rawData.raidData.month;
            }
            const now = new Date();
            return `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
        }

// ===========================================
// タブ切り替え機能 - Phase 1追加
// ===========================================

function switchTab(tabName) {
    // ページトップにスクロール
    window.scrollTo({ top: 0, behavior: 'smooth' });

    // すべてのタブボタンからactiveクラスを削除
    document.querySelectorAll('.tab-button').forEach(btn => {
        btn.classList.remove('active');
    });

    // すべてのタブコンテンツを非表示
    document.querySelectorAll('.tab-content').forEach(content => {
        content.classList.remove('active');
    });

    // 選択されたタブボタンにactiveクラスを追加
    const activeButton = document.querySelector('.tab-button[data-tab="' + tabName + '"]');
    const activeContent = document.getElementById('tab-' + tabName);

    if (activeButton) activeButton.classList.add('active');
    if (activeContent) activeContent.classList.add('active');

    // タブごとの初期化処理
    if (tabName === 'ranking' && processedData && processedData.length > 0) {
        // Tab1: グラフ再描画
        createAttributeStackedBarChart(processedData);
    } else if (tabName === 'slv-ranking' && processedData && processedData.length > 0) {
        // Tab2: SLv基準スコア
        createSLvComparisonChart(processedData);
        renderSlvEfficiencyRanking(processedData);
    } else if (tabName === 'characters') {
        // Tab3: 編成一覧表示更新
        if (typeof updateTeamCompositionsDisplay === 'function') {
            updateTeamCompositionsDisplay();
        }
    } else if (tabName === 'management') {
        // Tab4: データ状況表示更新
        if (typeof updateStorageInfo === 'function') {
            updateStorageInfo();
        }
    }

    console.log('タブ切り替え: ' + tabName);
}

function switchAttributeTab(attribute) {
    // 全属性タブボタンからactiveクラスを削除
    document.querySelectorAll('.attribute-tab-btn').forEach(btn => {
        btn.classList.remove('active');
    });

    // 選択された属性タブボタンにactiveクラスを追加
    const activeButton = document.querySelector('.attribute-tab-btn[data-attribute="' + attribute + '"]');
    if (activeButton) activeButton.classList.add('active');

    // 現在の属性を更新
    currentAttribute = attribute;

    // 編成一覧表示を更新
    updateTeamCompositionsDisplay();

    console.log('属性タブ切り替え: ' + attribute);
}

function updateStorageInfo() {
    var historyData = loadFromLocalStorage();
    var monthsCount = Object.keys(historyData).length;
    var monthsList = Object.keys(historyData).sort();

    // データ蓄積状況サマリーの更新
    var historyCountEl = document.getElementById('historyCount');
    if (historyCountEl) {
        historyCountEl.textContent = monthsCount;
    }

    // 保存期間の更新
    var dataRangeEl = document.getElementById('dataRangeDisplay');
    if (dataRangeEl) {
        if (monthsCount === 0) {
            dataRangeEl.textContent = 'データなし';
        } else if (monthsCount === 1) {
            dataRangeEl.textContent = monthsList[0];
        } else {
            dataRangeEl.textContent = `${monthsList[0]} 〜 ${monthsList[monthsList.length - 1]}`;
        }
    }

    var infoBox = document.getElementById('storageInfoBox');
    if (!infoBox) return;

    var monthsCountEl = document.getElementById('storageMonthsCount');
    var monthsListEl = document.getElementById('storageMonthsList');

    if (monthsCountEl) {
        monthsCountEl.textContent = monthsCount;
    }

    if (monthsListEl) {
        if (monthsCount === 0) {
            monthsListEl.innerHTML = '<p style="color: var(--text-muted); font-size: 0.875rem;">まだデータが蓄積されていません</p>';
        } else {
            monthsListEl.innerHTML = monthsList.map(function(month) {
                return '<span class="month-badge">' + month + '</span>';
            }).join('');
        }
    }
}

function exportCombinedJSON() {
    var historyData = loadFromLocalStorage();
    var monthsCount = Object.keys(historyData).length;
    
    if (monthsCount === 0) {
        alert('蓄積されたデータがありません。先に「データ蓄積」を実行してください。');
        return;
    }
    
    var dateStr = new Date().toISOString();
    var combined = {
        metadata: {
            exportedAt: dateStr,
            monthsCount: monthsCount,
            months: Object.keys(historyData).sort(),
            version: '2.0'
        },
        historyData: historyData
    };
    
    var blob = new Blob([JSON.stringify(combined, null, 2)], { type: 'application/json' });
    var url = URL.createObjectURL(blob);
    var a = document.createElement('a');
    a.href = url;
    a.download = 'nikke-raid-combined-' + monthsCount + 'months-' + dateStr.slice(0, 10) + '.json';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    console.log('総合データをエクスポートしました: ' + monthsCount + 'ヶ月分');
}

function generateDistributionHTML() {
    if (!processedData || processedData.length === 0) {
        if (!confirm('現在データが読み込まれていません。空の配布用HTMLを生成しますか？')) {
            return;
        }
    }

    try {
        // 現在のHTMLドキュメント全体を取得
        const currentHTML = document.documentElement.outerHTML;

        // DOMParserで解析
        const parser = new DOMParser();
        const doc = parser.parseFromString(currentHTML, 'text/html');

        // Tab3（データ管理）を削除
        const tab3Content = doc.getElementById('tab-management');
        if (tab3Content) {
            tab3Content.remove();
            console.log('Tab3コンテンツを削除しました');
        }

        // Tab3のナビゲーションボタンを削除
        const tab3Button = doc.querySelector('.tab-button[data-tab="management"]');
        if (tab3Button) {
            tab3Button.remove();
            console.log('Tab3ナビゲーションボタンを削除しました');
        }

        // 配布HTML生成ボタンを削除（再帰的生成を防ぐ）
        const generateButton = doc.querySelector('button[onclick="generateDistributionHTML()"]');
        if (generateButton && generateButton.parentElement) {
            generateButton.parentElement.parentElement.remove();
            console.log('配布HTML生成セクションを削除しました');
        }

        // タイトルを変更
        const titleEl = doc.querySelector('title');
        if (titleEl) {
            titleEl.textContent = 'しりすこPAD - Union Raid Analytics (配布版)';
        }

        // メタ情報を追加
        const metaComment = doc.createComment(`
        Generated by しりすこPAD Distribution Export
        Generated at: ${new Date().toISOString()}
        This is a read-only version without management features.
        `);
        doc.head.insertBefore(metaComment, doc.head.firstChild);

        // HTML文字列を生成
        const distributionHTML = '<!DOCTYPE html>\n' + doc.documentElement.outerHTML;

        // Blobを作成してダウンロード
        const blob = new Blob([distributionHTML], { type: 'text/html; charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;

        // ファイル名を生成（日付付き）
        const dateStr = new Date().toISOString().split('T')[0];
        a.download = `しりすこPAD_配布版_${dateStr}.html`;

        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        alert('配布用HTMLを生成しました！\n\nファイル名: ' + a.download + '\n\n配布版にはTab1（ランキング）とTab2（キャラクター分析）のみが含まれます。');
        console.log('配布用HTMLを生成しました:', a.download);

    } catch (error) {
        console.error('配布HTML生成エラー:', error);
        alert('配布HTML生成中にエラーが発生しました:\n' + error.message);
    }
}

        // ========================================
        // Phase 4: 通知システム
        // ========================================

        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.className = `notification notification-${type}`;
            notification.textContent = message;

            // 寒色系の色を使用
            let bgColor = '#0288D1'; // デフォルト: 青系
            if (type === 'success') {
                bgColor = '#0288D1'; // 青系（寒色）
            } else if (type === 'error') {
                bgColor = '#ef4444'; // 赤系
            } else {
                bgColor = '#00897B'; // 青緑系（寒色）
            }

            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 16px 24px;
                background: ${bgColor};
                color: white;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                z-index: 10000;
                animation: slideInRight 0.3s ease-out;
                font-size: 14px;
                max-width: 400px;
            `;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.style.animation = 'slideOutRight 0.3s ease-in';
                setTimeout(() => notification.remove(), 300);
            }, 3000);
        }

        function showResults() {
            errorArea.innerHTML = '';
            results.style.display = 'block';
            results.classList.add('animate-fade-in');
            updateStats();
            updateTable();

            // 新しいグラフを描画
            if (processedData && processedData.length > 0) {
                createAttributeStackedBarChart(processedData);
                createSLvComparisonChart(processedData);
                renderSlvEfficiencyRanking(processedData);
            }

            setupFilters();

            // 前月のユニオン順位を自動設定
            setPreviousUnionRank();

            // 過去データタブの情報を更新
            updateCurrentDataInfo();
        }

        // 前月のユニオン順位を自動設定
        function setPreviousUnionRank() {
            const allHistoryMonths = Object.keys(historyData).sort();
            const previousMonth = allHistoryMonths[allHistoryMonths.length - 1];

            if (previousMonth && historyData[previousMonth] && Array.isArray(historyData[previousMonth])) {
                const monthDataArray = historyData[previousMonth];
                const previousMonthData = monthDataArray[monthDataArray.length - 1];

                if (previousMonthData && previousMonthData.unionRank) {
                    const unionRankInput = document.getElementById('unionRankInput');
                    if (unionRankInput && !unionRankInput.value) {
                        unionRankInput.value = previousMonthData.unionRank;
                        currentUnionRank = previousMonthData.unionRank;
                        document.getElementById('unionRankStatus').textContent = `前月の順位（${previousMonth}）: ${previousMonthData.unionRank}%`;
                        console.log('前月のユニオン順位を設定:', previousMonthData.unionRank);
                    }
                }
            }
        }

        function updateStats() {
            const totalDamage = processedData.reduce((sum, p) => sum + p.damage, 0);
            const avgDamage = totalDamage / processedData.length;
            const avgSync = processedData.reduce((sum, p) => sum + p.syncLevel, 0) / processedData.length;

            // 新しい統計データの計算（攻撃詳細がある場合）
            let totalAttacks = 0;
            const uniqueBosses = new Set();
            const uniqueCharacters = new Set();
            let hasDetailedData = false;

            processedData.forEach(player => {
                if (player.attacks && Array.isArray(player.attacks) && player.attacks.length > 0) {
                    hasDetailedData = true;
                    totalAttacks += player.attacks.length;

                    player.attacks.forEach(attack => {
                        if (attack.bossType && attack.bossCode) {
                            uniqueBosses.add(`${attack.bossType} (${attack.bossCode})`);
                        } else if (attack.bossType) {
                            uniqueBosses.add(attack.bossType);
                        }

                        if (attack.characters && Array.isArray(attack.characters)) {
                            attack.characters.forEach(charUrl => {
                                uniqueCharacters.add(charUrl);
                            });
                        }
                    });
                }
            });

            // 基本統計カード（5つのみ）
            let statsHTML = `
                <div class="stat-card">
                    <h3>総ダメージ</h3>
                    <div class="value">${formatDamage(totalDamage)}</div>
                </div>
                <div class="stat-card">
                    <h3>参加者数</h3>
                    <div class="value">${processedData.length}</div>
                </div>
                <div class="stat-card">
                    <h3>平均ダメージ</h3>
                    <div class="value">${formatDamage(avgDamage)}</div>
                </div>
                <div class="stat-card">
                    <h3>平均SLv</h3>
                    <div class="value">${Math.round(avgSync)}</div>
                </div>
            `;

            // ユニオン順位カード（常に表示）
            let unionRankSource = '';
            if (currentUnionRank) {
                if (rawData?.metadata?.unionRank !== undefined && rawData.metadata.unionRank !== null) {
                    // latest.jsonから取得した場合
                    const extractedDate = rawData.metadata.extractedAt
                        ? new Date(rawData.metadata.extractedAt).toLocaleDateString('ja-JP', { month: 'short', day: 'numeric' })
                        : '';
                    unionRankSource = `<div style="font-size: 11px; color: var(--text-secondary); margin-top: 4px;">✅ データから取得${extractedDate ? ' (' + extractedDate + ')' : ''}</div>`;
                } else {
                    // 手動設定の場合
                    unionRankSource = '<div style="font-size: 11px; color: var(--text-secondary); margin-top: 4px;">✏️ 手動設定</div>';
                }
            }

            statsHTML += `
                <div class="stat-card clickable-card" onclick="showUnionRankTrend()" title="クリックして順位推移を表示">
                    <h3>🏆 ユニオン順位</h3>
                    <div class="value">${currentUnionRank ? `${currentUnionRank}%` : '未設定'}</div>
                    ${unionRankSource}
                    <div class="card-hint">推移を見る</div>
                </div>
            `;

            document.getElementById('statsGrid').innerHTML = statsHTML;

            // 編成一覧分析も更新
            analyzeTeamCompositions();
        }

        // 編成データを属性別に整理
        let teamCompositionsByAttribute = {};

        function analyzeTeamCompositions() {
            // 全属性と各属性別の編成データを初期化
            teamCompositionsByAttribute = {
                ALL: [],
                FIRE: [],
                WATER: [],
                ELECTRIC: [],
                IRON: [],
                WIND: []
            };

            let hasDetailedData = false;

            processedData.forEach(player => {
                if (player.attacks && Array.isArray(player.attacks) && player.attacks.length > 0) {
                    hasDetailedData = true;
                    player.attacks.forEach(attack => {
                        // ボスコードから属性を取得
                        const bossCode = attack.bossCode || attack.boss;
                        const bossInfo = bossCode ? BOSS_ATTRIBUTES[bossCode] : null;
                        const attribute = bossInfo ? bossInfo.attribute : null;
                        const bossName = attack.bossType || (bossInfo ? bossInfo.nameJP : '不明');

                        // 編成データを作成
                        const composition = {
                            player: player.player,
                            syncLevel: player.syncLevel || 0,
                            bossName: bossName,
                            bossCode: bossCode,
                            attribute: attribute,
                            attributeIcon: bossInfo ? bossInfo.icon : '',
                            attributeJP: bossInfo ? bossInfo.attributeJP : '',
                            damage: attack.damage || 0,
                            characters: attack.characters || [],
                            difficulty: attack.difficulty || '',
                            level: attack.level || 0
                        };

                        // 全属性統合に追加
                        teamCompositionsByAttribute.ALL.push(composition);

                        // 属性別に追加
                        if (attribute && teamCompositionsByAttribute[attribute]) {
                            teamCompositionsByAttribute[attribute].push(composition);
                        }
                    });
                }
            });

            // データがない場合は処理を中断
            if (!hasDetailedData || teamCompositionsByAttribute.ALL.length === 0) {
                console.warn('編成データがありません');
                return;
            }

            // 現在選択中の属性で編成一覧を更新
            updateTeamCompositionsDisplay();
        }

        function updateTeamCompositionsDisplay() {
            const container = document.getElementById('teamCompositionsContainer');
            if (!container) {
                console.error('teamCompositionsContainer要素が見つかりません');
                return;
            }

            const currentCompositions = teamCompositionsByAttribute[currentAttribute] || [];

            if (currentCompositions.length === 0) {
                container.innerHTML = '<p style="color: var(--md-sys-color-on-surface-variant); text-align: center; padding: 32px;">この属性のデータがありません</p>';
                return;
            }

            // ダメージでソート（降順）
            const sortedCompositions = [...currentCompositions].sort((a, b) => b.damage - a.damage);

            // 編成一覧をHTMLで表示
            container.innerHTML = sortedCompositions.map((comp, index) => `
                <div class="card" style="margin-bottom: 16px; padding: 16px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <img src="${comp.attributeIcon}" alt="${comp.attributeJP}" style="width: 24px; height: 24px;">
                            <strong style="font-size: 16px;">${comp.bossName}</strong>
                            ${comp.difficulty ? `<span class="badge" style="background: var(--md-sys-color-primary-container); color: var(--md-sys-color-on-primary-container); padding: 2px 8px; border-radius: 4px; font-size: 12px;">${comp.difficulty} Lv.${comp.level}</span>` : ''}
                        </div>
                        <div style="text-align: right;">
                            <div style="font-size: 18px; font-weight: 600; color: var(--md-sys-color-primary);">${formatDamage(comp.damage)}</div>
                            <div style="font-size: 12px; color: var(--md-sys-color-on-surface-variant);">${comp.player} (SLv ${comp.syncLevel})</div>
                        </div>
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 8px; max-width: 400px;">
                        ${comp.characters.map((charUrl, idx) => {
                            console.log(`[ランキング] Character ${idx}:`, charUrl, 'Type:', typeof charUrl);
                            if (typeof charUrl === 'string' && charUrl && !charUrl.includes('属性アイコン')) {
                                console.log(`[ランキング] ✓ 画像表示:`, charUrl);
                                return `<img src="${charUrl}" alt="キャラクター" style="width: 100%; aspect-ratio: 1/1; border-radius: 8px; object-fit: cover; border: 2px solid var(--border-color);" onerror="console.error('画像エラー:', '${charUrl}'); this.style.display='none';" onload="console.log('画像OK:', '${charUrl}')">`;
                            }
                            console.log(`[ランキング] ✗ スキップ:`, charUrl);
                            return '';
                        }).join('')}
                    </div>
                </div>
            `).join('');
        }

        function updateTable() {
            const tbody = document.getElementById('tableBody');
            tbody.innerHTML = filteredData.map(player => {
                const growthInfo = getPlayerGrowth(player.player);

                return `
                <tr class="player-row" onclick="showPlayerDetails('${player.player}')" data-player="${player.player}">
                    <td class="rank rank-${player.rank <= 3 ? player.rank : 'other'}">
                        ${player.rank <= 3 ? ['🥇', '🥈', '🥉'][player.rank - 1] : '#' + player.rank}
                    </td>
                    <td>
                        <strong>${player.player}</strong>
                        ${player.isUnion ? '<span class="badge badge-union">Union</span>' : ''}
                    </td>
                    <td>${formatDamage(player.damage)}</td>
                    <td>${player.syncLevel}</td>
                    <td>${growthInfo}</td>
                </tr>
                `;
            }).join('');
        }

        // プレイヤーの成長率を取得
        function getPlayerGrowth(playerName) {
            const playerGrowth = growthData.find(g => g.player === playerName);
            if (!playerGrowth || playerGrowth.monthlyData.length < 2) {
                return '<span style="color: #94a3b8;">-</span>';
            }

            const monthlyData = playerGrowth.monthlyData.sort((a, b) => a.month.localeCompare(b.month));
            const latest = monthlyData[monthlyData.length - 1];
            const previous = monthlyData[monthlyData.length - 2];

            const damageGrowth = calculateGrowthRate(latest.damage, previous.damage);
            const syncGrowth = latest.syncLevel - previous.syncLevel;

            const damageColor = damageGrowth > 0 ? '#22c55e' : damageGrowth < 0 ? '#ef4444' : '#94a3b8';
            const syncColor = syncGrowth > 0 ? '#22c55e' : syncGrowth < 0 ? '#ef4444' : '#94a3b8';

            return `
                <div style="display: flex; flex-direction: column; gap: 2px;">
                    <span style="color: ${damageColor}; font-size: 12px;">
                        DMG: ${damageGrowth >= 0 ? '+' : ''}${damageGrowth.toFixed(1)}%
                    </span>
                    <span style="color: ${syncColor}; font-size: 12px;">
                        SLv: ${syncGrowth >= 0 ? '+' : ''}${syncGrowth}
                    </span>
                </div>
            `;
        }

        // 成長率計算関数
        function calculateGrowthRate(current, previous) {
            if (previous === 0) return 0;
            return ((current - previous) / previous) * 100;
        }

        // 属性別積み上げ棒グラフ
        function createAttributeStackedBarChart(players) {
            const canvas = document.getElementById('attributeStackedChart');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');

            // プレイヤーをスコア順にソート（左から高い順）
            const sortedPlayers = [...players].sort((a, b) => b.damage - a.damage);

            // 各プレイヤーの属性別ダメージを集計
            const datasets = [];
            const attributeKeys = ['FIRE', 'WATER', 'ELECTRIC', 'IRON', 'WIND'];

            attributeKeys.forEach(attr => {
                const data = sortedPlayers.map(player => {
                    // プレイヤーの全攻撃から属性別ダメージを合計
                    if (!player.attacks || player.attacks.length === 0) return 0;

                    return player.attacks
                        .filter(attack => {
                            const bossAttr = getBossAttribute(attack.bossCode);
                            return bossAttr && bossAttr.attribute === attr;
                        })
                        .reduce((sum, attack) => sum + (attack.damage || 0), 0);
                });

                // 属性情報取得（最初に見つかったボスコードから）
                const sampleBossCode = Object.keys(BOSS_ATTRIBUTES).find(
                    code => BOSS_ATTRIBUTES[code].attribute === attr
                );
                const attrInfo = BOSS_ATTRIBUTES[sampleBossCode];

                datasets.push({
                    label: attrInfo.attributeJP,
                    data: data,
                    backgroundColor: attrInfo.color,
                    borderColor: attrInfo.color,
                    borderWidth: 0
                });
            });

            // 属性アイコン画像をプリロード
            const attributeImages = {};
            const imagePromises = attributeKeys.map(attr => {
                return new Promise((resolve) => {
                    const sampleBossCode = Object.keys(BOSS_ATTRIBUTES).find(
                        code => BOSS_ATTRIBUTES[code].attribute === attr
                    );
                    const attrInfo = BOSS_ATTRIBUTES[sampleBossCode];
                    const img = new Image();
                    img.src = attrInfo.icon;
                    img.onload = () => {
                        attributeImages[attr] = img;
                        resolve();
                    };
                    img.onerror = () => {
                        console.warn(`Failed to load icon: ${attrInfo.icon}`);
                        resolve();
                    };
                });
            });

            // 画像読み込み完了後にチャート作成
            Promise.all(imagePromises).then(() => {
                // 既存のチャートがあれば破棄
                if (window.attributeStackedChartInstance) {
                    window.attributeStackedChartInstance.destroy();
                }

                window.attributeStackedChartInstance = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: sortedPlayers.map(p => p.player),
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                stacked: true,
                                ticks: {
                                    color: 'var(--md-sys-color-on-surface)',
                                    font: {
                                        size: 12
                                    },
                                    maxRotation: 45,
                                    minRotation: 45
                                },
                                grid: {
                                    color: 'var(--md-sys-color-outline-variant)',
                                    display: false
                                }
                            },
                            y: {
                                stacked: true,
                                ticks: {
                                    color: 'var(--md-sys-color-on-surface)',
                                    callback: function(value) {
                                        return (value / 1000000000).toFixed(1) + 'B';
                                    }
                                },
                                grid: {
                                    color: 'var(--md-sys-color-outline-variant)'
                                }
                            }
                        },
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top',
                                onClick: function(e, legendItem, legend) {
                                    const index = legendItem.datasetIndex;
                                    const chart = legend.chart;
                                    const meta = chart.getDatasetMeta(index);

                                    // データセットの表示/非表示を切り替え
                                    meta.hidden = meta.hidden === null ? !chart.data.datasets[index].hidden : null;

                                    // チャートを更新
                                    chart.update();
                                },
                                labels: {
                                    color: 'var(--md-sys-color-on-surface)',
                                    padding: 15,
                                    font: {
                                        size: 13,
                                        weight: 500
                                    },
                                    usePointStyle: true,
                                    pointStyle: 'rectRounded',
                                    generateLabels: function(chart) {
                                        const datasets = chart.data.datasets;
                                        return datasets.map((dataset, i) => {
                                            const attr = attributeKeys[i];
                                            const sampleBossCode = Object.keys(BOSS_ATTRIBUTES).find(
                                                code => BOSS_ATTRIBUTES[code].attribute === attr
                                            );
                                            const attrInfo = BOSS_ATTRIBUTES[sampleBossCode];

                                            return {
                                                text: dataset.label,
                                                fillStyle: dataset.backgroundColor,
                                                strokeStyle: dataset.borderColor,
                                                lineWidth: 0,
                                                hidden: !chart.isDatasetVisible(i),
                                                index: i,
                                                datasetIndex: i,
                                                // 画像アイコンを使用するための拡張プロパティ
                                                pointStyle: (() => {
                                                    const img = attributeImages[attr];
                                                    if (img) {
                                                        const tempCanvas = document.createElement('canvas');
                                                        tempCanvas.width = 16;
                                                        tempCanvas.height = 16;
                                                        const tempCtx = tempCanvas.getContext('2d');
                                                        tempCtx.drawImage(img, 0, 0, 16, 16);
                                                        return tempCanvas;
                                                    }
                                                    return 'rectRounded';
                                                })()
                                            };
                                        });
                                    }
                                }
                            },
                            tooltip: {
                                mode: 'index',
                                intersect: false,
                                callbacks: {
                                    label: function(context) {
                                        const value = context.parsed.y;
                                        return `${context.dataset.label}: ${(value / 1000000000).toFixed(2)}B`;
                                    },
                                    footer: function(tooltipItems) {
                                        let total = 0;
                                        tooltipItems.forEach(item => {
                                            total += item.parsed.y;
                                        });
                                        return '合計: ' + (total / 1000000000).toFixed(2) + 'B';
                                    }
                                }
                            }
                        }
                    }
                });
            });
        }

        // SLv比較チャート
        function createSLvComparisonChart(players) {
            const canvas = document.getElementById('slvComparisonChart');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');

            // SLvでソート
            const sortedPlayers = [...players].sort((a, b) => a.syncLevel - b.syncLevel);

            // 既存のチャートがあれば破棄
            if (window.slvComparisonChartInstance) {
                window.slvComparisonChartInstance.destroy();
            }

            window.slvComparisonChartInstance = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: sortedPlayers.map(p => `${p.player} (SLv ${p.syncLevel})`),
                    datasets: [
                        {
                            label: 'スコア',
                            data: sortedPlayers.map(p => p.damage),
                            backgroundColor: 'var(--md-sys-color-primary)',
                            borderColor: 'var(--md-sys-color-primary)',
                            borderWidth: 1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            ticks: {
                                color: 'var(--md-sys-color-on-surface)',
                                font: { size: 11 },
                                maxRotation: 45,
                                minRotation: 45
                            },
                            grid: {
                                color: 'var(--md-sys-color-outline-variant)',
                                display: false
                            }
                        },
                        y: {
                            ticks: {
                                color: 'var(--md-sys-color-on-surface)',
                                callback: function(value) {
                                    return (value / 1000000000).toFixed(1) + 'B';
                                }
                            },
                            grid: {
                                color: 'var(--md-sys-color-outline-variant)'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            labels: {
                                color: 'var(--md-sys-color-on-surface)',
                                font: { size: 13, weight: 500 }
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const value = context.parsed.y;
                                    return `${context.dataset.label}: ${(value / 1000000000).toFixed(2)}B`;
                                }
                            }
                        }
                    }
                }
            });
        }

        // SLv効率ランキング表示
        function renderSlvEfficiencyRanking(players) {
            const tbody = document.getElementById('slvEfficiencyTableBody');
            if (!tbody) return;

            // SLvが0のプレイヤーを除外して効率を計算
            const playersWithEfficiency = players
                .filter(p => p.syncLevel && p.syncLevel > 0)
                .map(p => ({
                    ...p,
                    efficiency: p.damage / p.syncLevel
                }))
                .sort((a, b) => b.efficiency - a.efficiency);

            // テーブルを生成
            tbody.innerHTML = playersWithEfficiency.map((player, index) => {
                const rank = index + 1;
                const efficiencyFormatted = (player.efficiency / 1000000).toFixed(2) + 'M';
                const damageFormatted = formatDamage(player.damage);

                // タブ1と同じ順位表示形式
                const rankDisplay = rank <= 3
                    ? ['🥇', '🥈', '🥉'][rank - 1]
                    : '#' + rank;

                return `
                    <tr class="player-row" onclick="showPlayerDetails('${player.player}')" data-player="${player.player}">
                        <td class="rank rank-${rank <= 3 ? rank : 'other'}">
                            ${rankDisplay}
                        </td>
                        <td>
                            <strong>${player.player}</strong>
                            ${player.isUnion ? '<span class="badge badge-union">Union</span>' : ''}
                        </td>
                        <td style="text-align: right; font-weight: 600; color: var(--md-sys-color-primary);">
                            ${efficiencyFormatted}
                        </td>
                        <td>${damageFormatted}</td>
                        <td>${player.syncLevel}</td>
                    </tr>
                `;
            }).join('');
        }

        // SLv効率ランキングのソート
        let currentSlvEfficiencySort = { column: 'efficiency', direction: 'desc' };

        function sortSlvEfficiency(column) {
            // ソート方向の切り替え
            if (currentSlvEfficiencySort.column === column) {
                currentSlvEfficiencySort.direction =
                    currentSlvEfficiencySort.direction === 'asc' ? 'desc' : 'asc';
            } else {
                currentSlvEfficiencySort.column = column;
                currentSlvEfficiencySort.direction = 'desc';
            }

            // ソートインジケーターを更新
            document.querySelectorAll('[id^="slv-sort-"]').forEach(el => {
                el.textContent = '';
            });
            const indicator = document.getElementById('slv-sort-' + column);
            if (indicator) {
                indicator.textContent = currentSlvEfficiencySort.direction === 'asc' ? '▲' : '▼';
            }

            // データをソート
            const tbody = document.getElementById('slvEfficiencyTableBody');
            if (!tbody || !processedData) return;

            const playersWithEfficiency = processedData
                .filter(p => p.syncLevel && p.syncLevel > 0)
                .map(p => ({
                    ...p,
                    efficiency: p.damage / p.syncLevel
                }));

            // ソート
            playersWithEfficiency.sort((a, b) => {
                let aVal, bVal;

                if (column === 'efficiency') {
                    aVal = a.efficiency;
                    bVal = b.efficiency;
                } else if (column === 'damage') {
                    aVal = a.damage;
                    bVal = b.damage;
                } else if (column === 'slv') {
                    aVal = a.syncLevel;
                    bVal = b.syncLevel;
                } else if (column === 'name') {
                    return currentSlvEfficiencySort.direction === 'asc'
                        ? a.player.localeCompare(b.player)
                        : b.player.localeCompare(a.player);
                } else {
                    return 0;
                }

                return currentSlvEfficiencySort.direction === 'asc'
                    ? aVal - bVal
                    : bVal - aVal;
            });

            // テーブルを再描画
            tbody.innerHTML = playersWithEfficiency.map((player, index) => {
                const rank = index + 1;
                const efficiencyFormatted = (player.efficiency / 1000000).toFixed(2) + 'M';
                const damageFormatted = formatDamage(player.damage);

                const rankDisplay = rank <= 3
                    ? ['🥇', '🥈', '🥉'][rank - 1]
                    : '#' + rank;

                return `
                    <tr class="player-row" onclick="showPlayerDetails('${player.player}')" data-player="${player.player}">
                        <td class="rank rank-${rank <= 3 ? rank : 'other'}">
                            ${rankDisplay}
                        </td>
                        <td>
                            <strong>${player.player}</strong>
                            ${player.isUnion ? '<span class="badge badge-union">Union</span>' : ''}
                        </td>
                        <td style="text-align: right; font-weight: 600; color: var(--md-sys-color-primary);">
                            ${efficiencyFormatted}
                        </td>
                        <td>${damageFormatted}</td>
                        <td>${player.syncLevel}</td>
                    </tr>
                `;
            }).join('');
        }

        function updateChart() {
            const ctx = document.getElementById('damageChart').getContext('2d');
            const chartCount = document.getElementById('chartCount').value;
            const chartType = document.getElementById('chartType').value;

            // テーマを再取得
            currentTheme = document.body.getAttribute('data-theme') || 'light';
            const isDarkMode = currentTheme === 'dark';
            const textColor = isDarkMode ? '#ffffff' : '#475569';

            // 表示する人数を決定
            let topPlayers;
            if (chartCount === 'all') {
                topPlayers = filteredData;
            } else {
                topPlayers = filteredData.slice(0, parseInt(chartCount));
            }

            // 既存のチャートがあれば破棄
            if (window.myChart) {
                window.myChart.destroy();
            }

            if (chartType === 'damageSyncBar') {
                // ダメージ降順×シンクロレベル棒グラフの設定
                // ダメージ順にソート済みなので、そのまま使用
                const sortedByDamage = topPlayers;

                // ダメージ量に応じて色のグラデーションを作成
                function generateBarColors(players) {
                    const maxDamage = Math.max(...players.map(p => p.damage));
                    const minDamage = Math.min(...players.map(p => p.damage));

                    return players.map(player => {
                        // ダメージの割合を0-1の範囲に正規化
                        const ratio = (player.damage - minDamage) / (maxDamage - minDamage);

                        if (isDarkMode) {
                            // ダークテーマ: 紫からシアンのグラデーション
                            const r = Math.round(139 + (6 - 139) * ratio);    // 139→6 (紫→シアン)
                            const g = Math.round(92 + (182 - 92) * ratio);    // 92→182
                            const b = Math.round(246 + (212 - 246) * ratio);  // 246→212
                            return `rgba(${r}, ${g}, ${b}, 0.8)`;
                        } else {
                            // ライトテーマ: ブルー系のグラデーション
                            const r = Math.round(59 + (37 - 59) * ratio);     // 59→37
                            const g = Math.round(130 + (99 - 130) * ratio);   // 130→99
                            const b = Math.round(246 + (235 - 246) * ratio);  // 246→235
                            return `rgba(${r}, ${g}, ${b}, 0.8)`;
                        }
                    });
                }

                const barColors = generateBarColors(sortedByDamage);
                const borderColors = barColors.map(color => color.replace('0.8', '1'));

                window.myChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: sortedByDamage.map(p => p.player),
                        datasets: [{
                            label: 'シンクロレベル',
                            data: sortedByDamage.map(p => p.syncLevel),
                            backgroundColor: barColors,
                            borderColor: borderColors,
                            borderWidth: 2,
                            borderRadius: {
                                topLeft: 6,
                                topRight: 6,
                                bottomLeft: 0,
                                bottomRight: 0
                            },
                            borderSkipped: false,
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            intersect: false,
                            mode: 'index'
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: chartCount === 'all'
                                    ? `全${sortedByDamage.length}プレイヤー (ダメージ順 × シンクロレベル)`
                                    : `トップ${chartCount}プレイヤー (ダメージ順 × シンクロレベル)`,
                                color: textColor,
                                font: {
                                    size: 18,
                                    weight: 'bold',
                                    family: "'Inter', sans-serif"
                                },
                                padding: {
                                    top: 15,
                                    bottom: 25
                                }
                            },
                            legend: {
                                display: true,
                                position: 'top',
                                labels: {
                                    color: textColor,
                                    font: {
                                        size: 13,
                                        family: "'Inter', sans-serif"
                                    },
                                    padding: 20,
                                    usePointStyle: false,
                                    boxWidth: 15,
                                    boxHeight: 15
                                }
                            },
                            tooltip: {
                                backgroundColor: isDarkMode ? 'rgba(17, 24, 39, 0.95)' : 'rgba(255, 255, 255, 0.95)',
                                titleColor: isDarkMode ? '#ffffff' : '#1f2937',
                                bodyColor: isDarkMode ? '#ffffff' : '#1f2937',
                                borderColor: isDarkMode ? '#8b5cf6' : '#3b82f6',
                                borderWidth: 1,
                                cornerRadius: 8,
                                callbacks: {
                                    title: function(context) {
                                        return '🎯 ' + context[0].label;
                                    },
                                    label: function(context) {
                                        const player = sortedByDamage[context.dataIndex];
                                        return [
                                            'ダメージ: ' + formatDamage(player.damage) + ' (#' + (context.dataIndex + 1) + ')',
                                            'シンクロレベル: ' + player.syncLevel
                                        ];
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: 'プレイヤー (ダメージ降順)',
                                    color: textColor,
                                    font: {
                                        size: 14,
                                        weight: 'bold',
                                        family: "'Inter', sans-serif"
                                    }
                                },
                                ticks: {
                                    color: textColor,
                                    font: {
                                        size: 11,
                                        family: "'Inter', sans-serif"
                                    },
                                    maxRotation: 45,
                                    minRotation: 45
                                },
                                grid: {
                                    color: 'var(--chart-grid)',
                                    lineWidth: 1
                                }
                            },
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'シンクロレベル',
                                    color: textColor,
                                    font: {
                                        size: 14,
                                        weight: 'bold',
                                        family: "'Inter', sans-serif"
                                    }
                                },
                                ticks: {
                                    color: textColor,
                                    font: {
                                        size: 12,
                                        family: "'Inter', sans-serif"
                                    },
                                    callback: function(value) {
                                        return value;
                                    }
                                },
                                grid: {
                                    color: 'var(--chart-grid)',
                                    lineWidth: 1
                                }
                            }
                        },
                        animation: {
                            duration: 1200,
                            easing: 'easeOutQuart'
                        }
                    }
                });
            } else if (chartType === 'pie') {
                // 円グラフの設定 - テーマに応じたカラーパレット（拡張版）
                const lightPieColors = [
                    '#2563eb', '#dc2626', '#059669', '#ea580c', '#7c3aed',
                    '#0891b2', '#65a30d', '#c2410c', '#be185d', '#4338ca',
                    '#0369a1', '#b91c1c', '#047857', '#d97706', '#6d28d9',
                    '#0e7490', '#4d7c0f', '#9a3412', '#a21caf', '#3730a3',
                    '#075985', '#991b1b', '#065f46', '#b45309', '#5b21b6',
                    '#0c4a6e', '#7f1d1d', '#064e3b', '#92400e', '#581c87',
                    '#082f49', '#450a0a', '#022c22', '#78350f', '#44337a'
                ];
                const darkPieColors = [
                    '#8b5cf6', '#06b6d4', '#10b981', '#f59e0b', '#ef4444',
                    '#3b82f6', '#22c55e', '#f97316', '#ec4899', '#6366f1',
                    '#60a5fa', '#fb7185', '#34d399', '#fbbf24', '#a78bfa',
                    '#38bdf8', '#4ade80', '#fb923c', '#f472b6', '#818cf8',
                    '#93c5fd', '#fca5a5', '#6ee7b7', '#fcd34d', '#c4b5fd',
                    '#7dd3fc', '#86efac', '#fdba74', '#f9a8d4', '#a5b4fc',
                    '#bfdbfe', '#fecaca', '#a7f3d0', '#fde68a', '#ddd6fe'
                ];

                // 必要な分だけ色を生成
                function generateColors(baseColors, count) {
                    if (count <= baseColors.length) {
                        return baseColors.slice(0, count);
                    }

                    const colors = [...baseColors];
                    const hues = [0, 30, 60, 90, 120, 150, 180, 210, 240, 270, 300, 330];
                    const saturations = [70, 60, 80, 50];
                    const lightnesses = currentTheme === 'dark' ? [60, 65, 55] : [45, 50, 40];

                    while (colors.length < count) {
                        for (let h of hues) {
                            for (let s of saturations) {
                                for (let l of lightnesses) {
                                    if (colors.length >= count) break;
                                    colors.push(`hsl(${h}, ${s}%, ${l}%)`);
                                }
                                if (colors.length >= count) break;
                            }
                            if (colors.length >= count) break;
                        }
                    }
                    return colors.slice(0, count);
                }

                const pieColors = generateColors(
                    currentTheme === 'dark' ? darkPieColors : lightPieColors,
                    topPlayers.length
                );

                window.myChart = new Chart(ctx, {
                    type: 'pie',
                    data: {
                        labels: topPlayers.map(p => p.player),
                        datasets: [{
                            label: 'ダメージ',
                            data: topPlayers.map(p => p.damage),
                            backgroundColor: pieColors,
                            borderColor: '#ffffff',
                            borderWidth: 2,
                            hoverOffset: 6
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        layout: {
                            padding: {
                                top: 10,
                                bottom: 10,
                                left: 10,
                                right: 10
                            }
                        },
                        plugins: {
                            title: {
                                display: false
                            },
                            legend: {
                                display: true,
                                position: 'bottom',
                                labels: {
                                    color: 'var(--chart-text)',
                                    font: {
                                        size: 11,
                                        family: "'Inter', sans-serif"
                                    },
                                    padding: 12,
                                    usePointStyle: true,
                                    pointStyle: 'circle',
                                    boxWidth: 12,
                                    boxHeight: 12
                                }
                            },
                            tooltip: {
                                backgroundColor: 'rgba(17, 24, 39, 0.95)',
                                titleColor: '#f9fafb',
                                bodyColor: '#f9fafb',
                                borderColor: '#3b82f6',
                                borderWidth: 1,
                                cornerRadius: 8,
                                callbacks: {
                                    title: function(context) {
                                        return '🏆 ' + context[0].label;
                                    },
                                    label: function(context) {
                                        const player = topPlayers[context.dataIndex];
                                        const total = topPlayers.reduce((sum, p) => sum + p.damage, 0);
                                        const percentage = ((player.damage / total) * 100).toFixed(1);
                                        return [
                                            'ダメージ: ' + formatDamage(player.damage),
                                            '割合: ' + percentage + '%',
                                            'SLv: ' + player.syncLevel
                                        ];
                                    }
                                }
                            }
                        },
                        animation: {
                            duration: 1000,
                            easing: 'easeOutQuart'
                        }
                    }
                });
            } else {
                // 棒グラフの設定 - テーマに応じたグラデーション
                const gradient = ctx.createLinearGradient(0, 0, 0, 400);
                if (currentTheme === 'dark') {
                    gradient.addColorStop(0, 'rgba(139, 92, 246, 0.8)');
                    gradient.addColorStop(1, 'rgba(139, 92, 246, 0.3)');
                } else {
                    gradient.addColorStop(0, 'rgba(59, 130, 246, 0.8)');
                    gradient.addColorStop(1, 'rgba(59, 130, 246, 0.3)');
                }

                window.myChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: topPlayers.map(p => p.player),
                        datasets: [{
                            label: 'ダメージ',
                            data: topPlayers.map(p => p.damage / 10000),
                            backgroundColor: gradient,
                            borderColor: currentTheme === 'dark' ? '#8b5cf6' : '#3b82f6',
                            borderWidth: 2,
                            borderRadius: {
                                topLeft: 8,
                                topRight: 8,
                                bottomLeft: 0,
                                bottomRight: 0
                            },
                            borderSkipped: false,
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            intersect: false,
                            mode: 'index'
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: chartCount === 'all'
                                    ? `全${topPlayers.length}プレイヤー (ダメージランキング)`
                                    : `トップ${chartCount}プレイヤー (ダメージランキング)`,
                                color: 'var(--chart-text)',
                                font: {
                                    size: 18,
                                    weight: 'bold',
                                    family: "'Inter', sans-serif"
                                },
                                padding: 20
                            },
                            legend: {
                                display: false
                            },
                            tooltip: {
                                backgroundColor: 'rgba(17, 24, 39, 0.95)',
                                titleColor: '#f9fafb',
                                bodyColor: '#f9fafb',
                                borderColor: '#3b82f6',
                                borderWidth: 1,
                                cornerRadius: 8,
                                displayColors: false,
                                callbacks: {
                                    title: function(context) {
                                        return '🏆 ' + context[0].label;
                                    },
                                    label: function(context) {
                                        const player = topPlayers[context.dataIndex];
                                        return [
                                            'ダメージ: ' + formatDamage(player.damage),
                                            'SLv: ' + player.syncLevel
                                        ];
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                grid: {
                                    display: false
                                },
                                ticks: {
                                    color: 'var(--chart-text)',
                                    font: {
                                        size: 12,
                                        weight: '500'
                                    },
                                    maxRotation: 45,
                                    minRotation: 0
                                }
                            },
                            y: {
                                beginAtZero: true,
                                grid: {
                                    color: 'var(--chart-grid)',
                                    lineWidth: 1
                                },
                                ticks: {
                                    color: 'var(--chart-text)',
                                    font: {
                                        size: 12
                                    },
                                    callback: function(value) {
                                        if (value >= 10000) {
                                            return (value / 10000).toFixed(0) + '億';
                                        }
                                        return value.toFixed(0) + '万';
                                    }
                                }
                            }
                        },
                        animation: {
                            duration: 1000,
                            easing: 'easeOutQuart'
                        }
                    }
                });
            }

            if (chartType === 'bossDamageBreakdown') {
                // ボス別ダメージ内訳の円グラフ
                const bossStats = {};

                filteredData.forEach(player => {
                    if (player.attacks && Array.isArray(player.attacks)) {
                        player.attacks.forEach(attack => {
                            const bossKey = attack.bossCode
                                ? `${attack.bossType} (${attack.bossCode})`
                                : (attack.bossType || '不明');

                            if (!bossStats[bossKey]) {
                                bossStats[bossKey] = { totalDamage: 0, attackCount: 0 };
                            }
                            bossStats[bossKey].totalDamage += (attack.damage || 0);
                            bossStats[bossKey].attackCount++;
                        });
                    }
                });

                const bossLabels = Object.keys(bossStats);
                const bossDamages = bossLabels.map(boss => bossStats[boss].totalDamage);

                // データがない場合の処理
                if (bossLabels.length === 0) {
                    window.myChart = new Chart(ctx, {
                        type: 'pie',
                        data: {
                            labels: ['データなし'],
                            datasets: [{
                                data: [1],
                                backgroundColor: ['rgba(149, 165, 166, 0.6)']
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                title: {
                                    display: true,
                                    text: 'ボス別ダメージ内訳（データなし）',
                                    color: textColor,
                                    font: { size: 18, weight: 'bold', family: "'Inter', sans-serif" }
                                },
                                legend: { display: false }
                            }
                        }
                    });
                    return;
                }

                // グラデーションカラー生成（紫系統）
                const bossColors = bossLabels.map((_, i) => {
                    const ratio = i / Math.max(bossLabels.length - 1, 1);
                    if (isDarkMode) {
                        const r = Math.round(139 + (168 - 139) * ratio);
                        const g = Math.round(92 + (85 - 92) * ratio);
                        const b = Math.round(246 + (247 - 246) * ratio);
                        return `rgba(${r}, ${g}, ${b}, 0.8)`;
                    } else {
                        const r = Math.round(99 + (168 - 99) * ratio);
                        const g = Math.round(102 + (85 - 102) * ratio);
                        const b = Math.round(241 + (247 - 241) * ratio);
                        return `rgba(${r}, ${g}, ${b}, 0.8)`;
                    }
                });

                window.myChart = new Chart(ctx, {
                    type: 'pie',
                    data: {
                        labels: bossLabels,
                        datasets: [{
                            label: 'ボス別総ダメージ',
                            data: bossDamages,
                            backgroundColor: bossColors,
                            borderWidth: 2,
                            borderColor: isDarkMode ? '#1f2937' : '#ffffff'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                position: 'right',
                                labels: {
                                    color: textColor,
                                    font: { size: 13, family: "'Inter', sans-serif" },
                                    padding: 15,
                                    boxWidth: 20,
                                    boxHeight: 20
                                }
                            },
                            title: {
                                display: true,
                                text: 'ボス別ダメージ内訳',
                                color: textColor,
                                font: { size: 18, weight: 'bold', family: "'Inter', sans-serif" },
                                padding: { top: 15, bottom: 25 }
                            },
                            tooltip: {
                                backgroundColor: isDarkMode ? 'rgba(17, 24, 39, 0.95)' : 'rgba(255, 255, 255, 0.95)',
                                titleColor: isDarkMode ? '#ffffff' : '#1f2937',
                                bodyColor: isDarkMode ? '#ffffff' : '#1f2937',
                                borderColor: isDarkMode ? '#8b5cf6' : '#3b82f6',
                                borderWidth: 1,
                                cornerRadius: 8,
                                callbacks: {
                                    label: function(context) {
                                        const boss = context.label;
                                        const damage = context.parsed;
                                        const total = bossDamages.reduce((a, b) => a + b, 0);
                                        const percentage = ((damage / total) * 100).toFixed(1);
                                        const stats = bossStats[boss];
                                        return [
                                            boss,
                                            `総ダメージ: ${formatDamage(damage)}`,
                                            `攻撃回数: ${stats.attackCount}回`,
                                            `割合: ${percentage}%`
                                        ];
                                    }
                                }
                            }
                        },
                        animation: {
                            duration: 1000,
                            easing: 'easeOutQuart'
                        }
                    }
                });
            }

            if (chartType === 'growthTrend') {
                // 成長トレンドチャートの設定
                if (growthData.length === 0) {
                    window.myChart = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: ['データなし'],
                            datasets: [{
                                label: '履歴データがありません',
                                data: [0],
                                backgroundColor: 'rgba(149, 165, 166, 0.6)',
                                borderColor: 'rgba(149, 165, 166, 1)',
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                title: {
                                    display: true,
                                    text: '成長トレンド（データなし）',
                                    color: textColor,
                                    font: { size: 18, weight: 'bold', family: "'Inter', sans-serif" }
                                }
                            }
                        }
                    });
                    return;
                }

                // 上位プレイヤーの成長データを取得
                const displayCount = chartCount === 'all' ? Math.min(10, growthData.length) : Math.min(parseInt(chartCount), growthData.length);
                const topGrowthPlayers = growthData.slice(0, displayCount);

                const allMonths = [...new Set(topGrowthPlayers.flatMap(p => p.monthlyData.map(d => d.month)))].sort();

                const colors = [
                    isDarkMode ? '#8b5cf6' : '#3b82f6',  // 紫/青
                    isDarkMode ? '#06b6d4' : '#059669',  // シアン/緑
                    isDarkMode ? '#f59e0b' : '#ea580c',  // アンバー/オレンジ
                    isDarkMode ? '#ef4444' : '#dc2626',  // 赤
                    isDarkMode ? '#10b981' : '#047857',  // エメラルド/緑
                    isDarkMode ? '#a855f7' : '#7c3aed',  // バイオレット
                    isDarkMode ? '#14b8a6' : '#0d9488',  // ティール
                    isDarkMode ? '#f97316' : '#c2410c',  // オレンジ
                    isDarkMode ? '#ec4899' : '#be185d',  // ピンク
                    isDarkMode ? '#6366f1' : '#4338ca'   // インディゴ
                ];

                const datasets = topGrowthPlayers.map((player, index) => {
                    const monthlyDataMap = new Map(player.monthlyData.map(d => [d.month, d.damage]));
                    const damageData = allMonths.map(month => {
                        const damage = monthlyDataMap.get(month);
                        return damage ? damage / 1000000 : null;  // 百万単位で表示
                    });

                    return {
                        label: player.player,
                        data: damageData,
                        borderColor: colors[index % colors.length],
                        backgroundColor: colors[index % colors.length] + '20',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.4,
                        pointRadius: 4,
                        pointHoverRadius: 6,
                        spanGaps: true  // データが欠けている月は線でつなぐ
                    };
                });

                window.myChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: allMonths,
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false,
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: `成長トレンド - 上位${displayCount}プレイヤー`,
                                color: textColor,
                                font: {
                                    size: 18,
                                    weight: 'bold',
                                    family: "'Inter', sans-serif"
                                },
                                padding: { top: 15, bottom: 25 }
                            },
                            legend: {
                                display: true,
                                position: 'top',
                                labels: {
                                    color: textColor,
                                    font: { size: 12, family: "'Inter', sans-serif" },
                                    padding: 15,
                                    usePointStyle: true,
                                    pointStyle: 'line',
                                    boxWidth: 20,
                                    boxHeight: 2
                                }
                            },
                            tooltip: {
                                backgroundColor: isDarkMode ? 'rgba(17, 24, 39, 0.95)' : 'rgba(255, 255, 255, 0.95)',
                                titleColor: isDarkMode ? '#ffffff' : '#1f2937',
                                bodyColor: isDarkMode ? '#ffffff' : '#1f2937',
                                borderColor: isDarkMode ? '#8b5cf6' : '#3b82f6',
                                borderWidth: 1,
                                cornerRadius: 8,
                                callbacks: {
                                    title: function(context) {
                                        return '📅 ' + context[0].label;
                                    },
                                    label: function(context) {
                                        const damage = context.parsed.y * 1000000;
                                        return context.dataset.label + ': ' + formatDamage(damage);
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: '月',
                                    color: textColor,
                                    font: { size: 14, weight: 'bold', family: "'Inter', sans-serif" }
                                },
                                ticks: {
                                    color: textColor,
                                    font: { size: 11, family: "'Inter', sans-serif" }
                                },
                                grid: { color: 'var(--chart-grid)', lineWidth: 1 }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'ダメージ (百万)',
                                    color: textColor,
                                    font: { size: 14, weight: 'bold', family: "'Inter', sans-serif" }
                                },
                                ticks: {
                                    color: textColor,
                                    font: { size: 12, family: "'Inter', sans-serif" },
                                    callback: function(value) {
                                        return value.toFixed(0) + 'M';
                                    }
                                },
                                grid: { color: 'var(--chart-grid)', lineWidth: 1 }
                            }
                        },
                        animation: {
                            duration: 1200,
                            easing: 'easeOutQuart'
                        }
                    }
                });
            }
        }

        function setupFilters() {
            const searchInput = document.getElementById('searchInput');
            const syncFilter = document.getElementById('syncFilter');
            const sortBy = document.getElementById('sortBy');

            [searchInput, syncFilter, sortBy].forEach(el => {
                if (el) {
                    el.addEventListener('change', applyFilters);
                    el.addEventListener('input', applyFilters);
                }
            });
        }

        function applyFilters() {
            const search = document.getElementById('searchInput').value.toLowerCase();
            const syncValue = document.getElementById('syncFilter').value;
            const sort = document.getElementById('sortBy').value;

            filteredData = processedData.filter(player => {
                const matchesSearch = !search || player.player.toLowerCase().includes(search);
                const matchesSync = !syncValue ||
                    (syncValue === '600' && player.syncLevel >= 600) ||
                    (syncValue === '550' && player.syncLevel >= 550 && player.syncLevel < 600) ||
                    (syncValue === '500' && player.syncLevel >= 500 && player.syncLevel < 550) ||
                    (syncValue === '450' && player.syncLevel >= 450 && player.syncLevel < 500) ||
                    (syncValue === '400' && player.syncLevel >= 400 && player.syncLevel < 450) ||
                    (syncValue === '0' && player.syncLevel < 400);

                return matchesSearch && matchesSync;
            });

            filteredData.sort((a, b) => {
                switch(sort) {
                    case 'syncLevel': return b.syncLevel - a.syncLevel;
                    default: return b.damage - a.damage;
                }
            });

            filteredData.forEach((player, index) => {
                player.displayRank = index + 1;
            });

            updateTable();
            updateChart();
        }

        function formatDamage(damage) {
            if (damage >= 1e8) {
                return (damage / 1e8).toFixed(2) + '億';
            }
            if (damage >= 1e4) {
                return (damage / 1e4).toFixed(2) + '万';
            }
            if (damage >= 1e3) {
                return (damage / 1e3).toFixed(1) + 'K';
            }
            return damage.toString();
        }

        function exportHTML() {
            if (!rawData) return;

            const htmlContent = generateFullHTML();
            const blob = new Blob([htmlContent], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `nikke-analytics-${rawData.raidData?.month || 'export'}.html`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function generateFullHTML() {
            return `<!DOCTYPE html>
<html><head><title>しりすこPAD レポート</title></head>
<body style="font-family:-apple-system,BlinkMacSystemFont,'SF Pro Display',sans-serif;padding:2rem;background:#f5f5f7;color:#1d1d1f;">
<h1>しりすこPAD レポート</h1>
<h2>${rawData.raidData?.month || 'Data Export'}</h2>
<table border="1" style="width:100%;border-collapse:collapse;border-color:#e5e7eb;">
<tr style="background:#f8fafc;"><th>順位</th><th>プレイヤー</th><th>ダメージ</th><th>SLv</th></tr>
${processedData.map(p => `<tr><td>${p.rank}</td><td>${p.player}</td><td>${formatDamage(p.damage)}</td><td>${p.syncLevel}</td></tr>`).join('')}
</table>
</body></html>`;
        }



        function loadSampleData() {
            const sampleData = {
                "raidData": {
                    "month": "2025-09",
                    "totalDamage": 50000000000,
                    "participantCount": 10,
                    "players": [
                        {"player": "Akira", "damage": 2500000000, "syncLevel": 650},
                        {"player": "Yuki", "damage": 2200000000, "syncLevel": 620},
                        {"player": "Sakura", "damage": 2000000000, "syncLevel": 600},
                        {"player": "Hiro", "damage": 1800000000, "syncLevel": 580},
                        {"player": "Mei", "damage": 1600000000, "syncLevel": 550},
                        {"player": "Ryu", "damage": 1400000000, "syncLevel": 520},
                        {"player": "Kira", "damage": 1200000000, "syncLevel": 500},
                        {"player": "Nova", "damage": 1000000000, "syncLevel": 480},
                        {"player": "Zero", "damage": 900000000, "syncLevel": 450},
                        {"player": "Luna", "damage": 800000000, "syncLevel": 420}
                    ]
                },
                "unionMembers": ["Akira", "Yuki", "Sakura", "Hiro", "Mei", "Ryu"],
                "historyData": {
                    "2025-07": [
                        {
                            "date": "2025-07-15",
                            "players": [
                                {"player": "Akira", "damage": 2100000000, "syncLevel": 600},
                                {"player": "Yuki", "damage": 1900000000, "syncLevel": 580},
                                {"player": "Sakura", "damage": 1700000000, "syncLevel": 560},
                                {"player": "Hiro", "damage": 1500000000, "syncLevel": 540},
                                {"player": "Mei", "damage": 1300000000, "syncLevel": 520},
                                {"player": "Ryu", "damage": 1200000000, "syncLevel": 480},
                                {"player": "Kira", "damage": 1000000000, "syncLevel": 460},
                                {"player": "Nova", "damage": 850000000, "syncLevel": 440},
                                {"player": "Zero", "damage": 750000000, "syncLevel": 420},
                                {"player": "Luna", "damage": 650000000, "syncLevel": 400}
                            ]
                        }
                    ],
                    "2025-08": [
                        {
                            "date": "2025-08-15",
                            "players": [
                                {"player": "Akira", "damage": 2300000000, "syncLevel": 630},
                                {"player": "Yuki", "damage": 2050000000, "syncLevel": 600},
                                {"player": "Sakura", "damage": 1850000000, "syncLevel": 580},
                                {"player": "Hiro", "damage": 1650000000, "syncLevel": 560},
                                {"player": "Mei", "damage": 1450000000, "syncLevel": 540},
                                {"player": "Ryu", "damage": 1300000000, "syncLevel": 500},
                                {"player": "Kira", "damage": 1100000000, "syncLevel": 480},
                                {"player": "Nova", "damage": 920000000, "syncLevel": 460},
                                {"player": "Zero", "damage": 820000000, "syncLevel": 435},
                                {"player": "Luna", "damage": 720000000, "syncLevel": 410}
                            ]
                        }
                    ],
                    "2025-09": [
                        {
                            "date": "2025-09-15",
                            "players": [
                                {"player": "Akira", "damage": 2500000000, "syncLevel": 650},
                                {"player": "Yuki", "damage": 2200000000, "syncLevel": 620},
                                {"player": "Sakura", "damage": 2000000000, "syncLevel": 600},
                                {"player": "Hiro", "damage": 1800000000, "syncLevel": 580},
                                {"player": "Mei", "damage": 1600000000, "syncLevel": 550},
                                {"player": "Ryu", "damage": 1400000000, "syncLevel": 520},
                                {"player": "Kira", "damage": 1200000000, "syncLevel": 500},
                                {"player": "Nova", "damage": 1000000000, "syncLevel": 480},
                                {"player": "Zero", "damage": 900000000, "syncLevel": 450},
                                {"player": "Luna", "damage": 800000000, "syncLevel": 420}
                            ]
                        }
                    ]
                }
            };

            console.log('サンプルデータ読み込み');
            rawData = sampleData;

            // ユニオン順位データは空の状態で開始
            unionRankHistory = {};
            currentUnionRank = null;

            // ローカルストレージに保存
            localStorage.setItem('nikke-union-rank-history', JSON.stringify(unionRankHistory));
            localStorage.removeItem('nikke-current-union-rank');

            processData();
            showResults();
        }

        function toggleDebug() {
            const debugInfo = document.getElementById('debugInfo');

            if (debugInfo.style.display === 'none') {
                debugInfo.style.display = 'block';
                updateDebugInfo();
            } else {
                debugInfo.style.display = 'none';
            }
        }

        function updateDebugInfo() {
            const debugContent = document.getElementById('debugContent');
            debugContent.innerHTML = `
                <strong>現在の状況:</strong><br>
                • rawData: ${rawData ? '読み込み済み' : '未読み込み'}<br>
                • processedData: ${processedData.length}件<br>
                • filteredData: ${filteredData.length}件<br>
                <br>
                ${rawData ? `
                <strong>データ詳細:</strong><br>
                • データ形式: ${rawData.players ? 'v8.0' : rawData.raidData ? 'v5.0' : '不明'}<br>
                • プレイヤー数: ${rawData.players?.length || rawData.raidData?.players?.length || 0}<br>
                • Union members: ${rawData.unionMembers?.length || 0}名<br>
                ` : ''}
                <br>
                <small>詳細なログはブラウザのコンソール（F12）で確認してください</small>
            `;
        }

        // SLv編集機能
        let originalSyncLevels = {};

        function showSyncLevelEditor() {
            if (!rawData || processedData.length === 0) {
                showError('データを先に読み込んでください');
                return;
            }

            originalSyncLevels = {};
            processedData.forEach(player => {
                originalSyncLevels[player.id] = player.syncLevel;
            });

            document.getElementById('syncLevelModal').style.display = 'flex';

            // モーダルの内容をトップにスクロール
            const modalContent = document.querySelector('#syncLevelModal .modal-content');
            if (modalContent) {
                modalContent.scrollTop = 0;
            }

            generateSyncLevelList();
            document.addEventListener('keydown', handleEscapeKey);
        }

        function closeSyncLevelEditor() {
            document.getElementById('syncLevelModal').style.display = 'none';
            document.removeEventListener('keydown', handleEscapeKey);
        }

        function handleEscapeKey(event) {
            if (event.key === 'Escape') {
                closeSyncLevelEditor();
            }
        }

        function generateSyncLevelList() {
            const listContainer = document.getElementById('syncLevelList');
            listContainer.innerHTML = processedData.map(player => `
                <div class="sync-level-item" data-player-id="${player.id}">
                    <div class="player-info">
                        <div class="player-name">${player.player}</div>
                        <div class="player-damage">ダメージ: ${formatDamage(player.damage)}</div>
                    </div>
                    <div class="sync-level-controls">
                        <label>SLv:</label>
                        <input type="number"
                               id="slv_${player.id}"
                               value="${player.syncLevel}"
                               min="0"
                               max="999"
                               onchange="updateSyncLevel('${player.id}', this.value)">
                        <button onclick="increaseSyncLevel('${player.id}', 5)" class="btn btn-sm btn-outline">+5</button>
                        <button onclick="increaseSyncLevel('${player.id}', 10)" class="btn btn-sm btn-primary">+10</button>
                    </div>
                </div>
            `).join('');
        }

        function filterSyncLevelList() {
            const searchTerm = document.getElementById('playerSearch').value.toLowerCase();
            const items = document.querySelectorAll('.sync-level-item');

            items.forEach(item => {
                const playerName = item.querySelector('.player-name').textContent.toLowerCase();
                item.style.display = playerName.includes(searchTerm) ? 'flex' : 'none';
            });
        }

        function updateSyncLevel(playerId, newValue) {
            const player = processedData.find(p => p.id === playerId);
            if (player) {
                player.syncLevel = parseInt(newValue) || 0;
            }
        }

        function increaseSyncLevel(playerId, increase) {
            const input = document.getElementById('slv_' + playerId);
            const currentValue = parseInt(input.value) || 0;
            const newValue = currentValue + increase;
            input.value = newValue;
            updateSyncLevel(playerId, newValue);
        }

        function applyBulkIncrease() {
            const increase = parseInt(document.getElementById('bulkIncrease').value) || 0;
            if (increase === 0) {
                alert('増加値を入力してください');
                return;
            }

            processedData.forEach(player => {
                const input = document.getElementById('slv_' + player.id);
                if (input) {
                    const currentValue = parseInt(input.value) || 0;
                    const newValue = currentValue + increase;
                    input.value = newValue;
                    updateSyncLevel(player.id, newValue);
                }
            });

            alert(`全員のSLvを +${increase} しました`);
        }

        function applySyncLevelChanges() {
            if (rawData.players) {
                rawData.players.forEach(originalPlayer => {
                    const updatedPlayer = processedData.find(p => p.id === originalPlayer.id);
                    if (updatedPlayer) {
                        originalPlayer.syncLevel = updatedPlayer.syncLevel;
                    }
                });
            } else if (rawData.raidData && rawData.raidData.players) {
                rawData.raidData.players.forEach(originalPlayer => {
                    const updatedPlayer = processedData.find(p => p.player === originalPlayer.player);
                    if (updatedPlayer) {
                        originalPlayer.syncLevel = updatedPlayer.syncLevel;
                    }
                });
            }

            processedData.sort((a, b) => b.damage - a.damage);
            processedData.forEach((player, index) => {
                player.rank = index + 1;
            });

            applyFilters();
            updateStats();
            updateChart();
            closeSyncLevelEditor();

            alert('SLvの変更が適用されました！\n\n更新されたデータをJSONとしてエクスポートできます。');
        }

        function exportUpdatedJSON() {
            if (!rawData) {
                alert('データがありません');
                return;
            }

            const blob = new Blob([JSON.stringify(rawData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `nikke-analytics-updated-${new Date().toISOString().slice(0, 10)}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // 履歴データエクスポート機能
        function exportHistoryData() {
            const history = loadFromLocalStorage();

            if (!history || Object.keys(history).length === 0) {
                alert('履歴データがありません。先にデータを蓄積してください。');
                return;
            }

            const blob = new Blob([JSON.stringify(history, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const today = new Date().toISOString().slice(0, 10);
            a.download = `nikke-history-${today}.json`;
            a.click();
            URL.revokeObjectURL(url);

            const monthCount = Object.keys(history).length;
            alert(`履歴データをエクスポートしました！\n\n保存された月数: ${monthCount}個\nファイル名: nikke-history-${today}.json`);
        }

        // 履歴データインポート機能
        function importHistoryData() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = function(event) {
                    try {
                        const importedHistory = JSON.parse(event.target.result);

                        if (!importedHistory || typeof importedHistory !== 'object') {
                            alert('無効な履歴データファイルです');
                            return;
                        }

                        // 既存の履歴データと統合
                        const existingHistory = loadFromLocalStorage();
                        const mergedHistory = { ...existingHistory };

                        let newMonthCount = 0;
                        let overwriteMonthCount = 0;

                        Object.keys(importedHistory).forEach(month => {
                            if (mergedHistory[month]) {
                                overwriteMonthCount++;
                            } else {
                                newMonthCount++;
                            }
                            mergedHistory[month] = importedHistory[month];
                        });

                        // ローカルストレージに保存
                        saveToLocalStorage(mergedHistory);
                        historyData = mergedHistory;

                        // 成長データを再生成
                        if (processedData && processedData.length > 0) {
                            generateGrowthData();
                            updateTable();
                            if (document.getElementById('chartType').value === 'growthTrend') {
                                updateChart();
                            }
                        }

                        alert(`履歴データをインポートしました！\n\n新規追加: ${newMonthCount}個の月\n上書き: ${overwriteMonthCount}個の月\n合計: ${Object.keys(mergedHistory).length}個の月`);
                    } catch (error) {
                        alert('ファイルの読み込みに失敗しました: ' + error.message);
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }

        // データ蓄積機能
        function accumulateData() {
            if (!processedData || processedData.length === 0) {
                alert('データが読み込まれていません。先にJSONファイルをアップロードしてください。');
                return;
            }

            // 年月選択モーダルを表示
            showYearMonthModal();
        }

        // 年月選択モーダルを表示
        function showYearMonthModal() {
            const now = new Date();
            document.getElementById('yearInput').value = now.getFullYear();
            document.getElementById('monthInput').value = now.getMonth() + 1;
            document.getElementById('yearMonthModal').style.display = 'flex';
        }

        // 年月選択モーダルを閉じる
        function closeYearMonthModal() {
            document.getElementById('yearMonthModal').style.display = 'none';
        }

        // 手順書モーダルを表示
        function showGuideModal() {
            document.getElementById('guideModal').style.display = 'flex';
        }

        // 手順書モーダルを閉じる
        function closeGuideModal() {
            document.getElementById('guideModal').style.display = 'none';
        }

        // 年月を確定してデータを保存
        function confirmYearMonth() {
            const year = parseInt(document.getElementById('yearInput').value);
            const month = parseInt(document.getElementById('monthInput').value);

            // 入力値の検証
            if (!year || year < 2020 || year > 2030) {
                alert('年は2020〜2030の範囲で入力してください');
                return;
            }

            if (!month || month < 1 || month > 12) {
                alert('月は1〜12の範囲で入力してください');
                return;
            }

            const monthKey = `${year}-${String(month).padStart(2, '0')}`; // YYYY-MM format
            const currentDate = `${monthKey}-15`; // 月の中旬を日付として使用

            // Union順位を取得
            const unionRankInput = document.getElementById('unionRankInput');
            const unionRank = unionRankInput && unionRankInput.value ? parseFloat(unionRankInput.value) : currentUnionRank;

            console.log('=== データ蓄積処理 ===');
            console.log('蓄積する月:', monthKey);
            console.log('Union順位:', unionRank);
            console.log('processedData:', processedData);
            console.log('processedDataの件数:', processedData.length);
            console.log('filteredData:', filteredData);
            console.log('filteredDataの件数:', filteredData.length);

            // 現在のデータを履歴に追加
            const dataToSave = {
                date: currentDate,
                players: processedData.map(player => ({
                    player: player.player,
                    damage: player.damage,
                    syncLevel: player.syncLevel
                })),
                unionRank: unionRank,
                totalDamage: processedData.reduce((sum, p) => sum + p.damage, 0)
            };

            console.log('保存するデータ:', dataToSave);
            console.log('保存するプレイヤー数:', dataToSave.players.length);

            // ローカルストレージから既存の履歴データを取得
            let savedHistory = loadFromLocalStorage();

            // 月ごとのデータ構造を作成
            if (!savedHistory[monthKey]) {
                savedHistory[monthKey] = [];
            }

            // 同じ日付のデータがある場合は上書き、ない場合は追加
            const existingIndex = savedHistory[monthKey].findIndex(data => data.date === currentDate);
            if (existingIndex >= 0) {
                savedHistory[monthKey][existingIndex] = dataToSave;
                alert(`${monthKey} のデータを上書きしました\n保存されたプレイヤー数: ${dataToSave.players.length}名`);
            } else {
                savedHistory[monthKey].push(dataToSave);
                alert(`${monthKey} のデータを蓄積しました\n保存されたプレイヤー数: ${dataToSave.players.length}名`);
            }

            // ローカルストレージに保存
            saveToLocalStorage(savedHistory);

            // グローバル変数を更新
            historyData = savedHistory;

            console.log(`データを蓄積しました（${currentDate}）\n月: ${monthKey}\n保存されたプレイヤー数: ${dataToSave.players.length}名`);

            // テーブルと成長データを更新
            if (processedData.length > 0) {
                generateGrowthData();
                updateTable();
                if (document.getElementById('chartType').value === 'growthTrend') {
                    updateChart();
                }
            }

            // モーダルを閉じる
            closeYearMonthModal();
        }

        // ローカルストレージにデータを保存
        function saveToLocalStorage(data) {
            try {
                localStorage.setItem('nikke-analytics-history', JSON.stringify(data));
                console.log('履歴データをローカルストレージに保存しました:', data);
            } catch (error) {
                console.error('ローカルストレージへの保存に失敗しました:', error);
                alert('データの保存に失敗しました。ブラウザの容量が不足している可能性があります。');
            }
        }

        // ローカルストレージからデータを読み込み
        function loadFromLocalStorage() {
            try {
                const savedData = localStorage.getItem('nikke-analytics-history');
                if (savedData) {
                    const parsed = JSON.parse(savedData);
                    console.log('履歴データをローカルストレージから読み込みました:', parsed);
                    return parsed;
                }
            } catch (error) {
                console.error('ローカルストレージからの読み込みに失敗しました:', error);
            }
            return {};
        }

        // 個人詳細表示機能
        let playerDamageChart = null;
        let playerSyncChart = null;

        function showPlayerDetails(playerName) {
            // デバッグ情報
            console.log('=== showPlayerDetails 呼び出し ===');
            console.log('プレイヤー名:', playerName);
            console.log('growthData:', growthData);
            console.log('historyData:', historyData);

            // 現在のデータから攻撃情報を取得
            const currentPlayer = processedData.find(p => p.player === playerName);
            console.log('現在のプレイヤーデータ:', currentPlayer);

            // プレイヤーの履歴データを取得
            const playerGrowth = growthData.find(g => g.player === playerName);
            if (!playerGrowth) {
                console.error('プレイヤーの履歴データが見つかりません:', playerName);
                console.log('利用可能なプレイヤー:', growthData.map(g => g.player));
                alert('このプレイヤーの履歴データが見つかりません。\n\nデバッグ情報:\n- 成長データ数: ' + growthData.length + '\n- 履歴データ月数: ' + Object.keys(historyData).length);
                return;
            }

            console.log('プレイヤーの成長データ:', playerGrowth);

            // モーダルタイトルを設定
            document.getElementById('playerModalTitle').textContent = `${playerName} の成績推移`;

            // ボス別攻撃詳細を表示
            if (currentPlayer && currentPlayer.attacks) {
                renderPlayerAttacks(currentPlayer.attacks);
            } else {
                // 攻撃データがない場合は空のコンテナを表示
                document.getElementById('playerAttacksContainer').innerHTML =
                    '<p style="color: var(--text-secondary); padding: 1rem;">攻撃データがありません</p>';
            }

            // 履歴テーブルを生成
            renderPlayerHistoryTable(playerGrowth.monthlyData);

            // モーダルを表示
            document.getElementById('playerModal').style.display = 'flex';

            // モーダルの内容をトップにスクロール
            const modalContent = document.querySelector('#playerModal .modal-content');
            if (modalContent) {
                modalContent.scrollTop = 0;
            }

            // グラフを描画（少し遅延して実行）
            setTimeout(() => {
                renderPlayerCharts(playerGrowth.monthlyData, playerName);
            }, 100);
        }

        function renderPlayerAttacks(attacks) {
            const container = document.getElementById('playerAttacksContainer');

            if (!attacks || attacks.length === 0) {
                container.innerHTML = '<p style="color: var(--text-secondary); padding: 1rem;">攻撃データがありません</p>';
                return;
            }

            // 攻撃を属性別にグループ化
            const attacksByAttribute = {};

            attacks.forEach(attack => {
                const bossCode = attack.bossCode || attack.boss;
                if (!bossCode) return;

                const bossInfo = BOSS_ATTRIBUTES[bossCode];
                if (!bossInfo) return;

                const attribute = bossInfo.attribute;
                if (!attacksByAttribute[attribute]) {
                    attacksByAttribute[attribute] = {
                        info: bossInfo,
                        attacks: []
                    };
                }

                attacksByAttribute[attribute].attacks.push(attack);
            });

            // 属性順（BOSS_ATTRIBUTESの定義順）でソート
            const attributeOrder = ['FIRE', 'WATER', 'ELECTRIC', 'IRON', 'WIND'];
            const sortedAttributes = attributeOrder.filter(attr => attacksByAttribute[attr]);

            // HTMLを生成
            let html = '';

            sortedAttributes.forEach(attribute => {
                const group = attacksByAttribute[attribute];
                const bossInfo = group.info;

                // ボス名を取得（最初の攻撃から）
                const firstAttack = group.attacks[0];
                const bossName = firstAttack.bossType || bossInfo.nameJP;

                html += `
                    <div class="attribute-attack-group">
                        <div class="attribute-attack-header">
                            <img src="${bossInfo.icon}" alt="${bossInfo.attributeJP}" class="attribute-attack-icon">
                            <div class="attribute-attack-title">${bossName}</div>
                        </div>
                        <div class="attribute-attacks-list">
                `;

                // 各攻撃を表示（ダメージ順）
                group.attacks
                    .sort((a, b) => (b.damage || 0) - (a.damage || 0))
                    .forEach((attack, index) => {
                        const damage = attack.damage || 0;
                        const characters = attack.characters || [];

                        html += `
                            <div class="attack-item">
                                <div class="attack-characters">
                        `;

                        // キャラクター画像を表示（charactersは文字列URLの配列）
                        characters.forEach((charUrl, idx) => {
                            console.log(`[編成一覧] Character ${idx}:`, charUrl, 'Type:', typeof charUrl);
                            // charUrlは文字列（画像URL）そのもの
                            if (typeof charUrl === 'string' && charUrl && !charUrl.includes('属性アイコン')) {
                                console.log(`[編成一覧] ✓ 画像表示:`, charUrl);
                                html += `
                                    <img src="${charUrl}"
                                         alt="Character"
                                         class="attack-character-img"
                                         onerror="console.error('画像エラー:', '${charUrl}'); this.style.display='none';"
                                         onload="console.log('画像OK:', '${charUrl}')">
                                `;
                            } else {
                                console.log(`[編成一覧] ✗ スキップ:`, charUrl);
                            }
                        });

                        html += `
                                </div>
                                <div class="attack-damage">${formatDamage(damage)}</div>
                            </div>
                        `;
                    });

                html += `
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        function hidePlayerDetails() {
            document.getElementById('playerModal').style.display = 'none';

            // 既存のチャートを破棄
            if (playerDamageChart) {
                playerDamageChart.destroy();
                playerDamageChart = null;
            }
            if (playerSyncChart) {
                playerSyncChart.destroy();
                playerSyncChart = null;
            }
        }

        function renderPlayerHistoryTable(monthlyData) {
            const tbody = document.getElementById('playerHistoryTableBody');
            const sortedData = monthlyData.sort((a, b) => a.month.localeCompare(b.month));

            tbody.innerHTML = sortedData.map((data, index) => {
                const prevData = index > 0 ? sortedData[index - 1] : null;

                // 前月との差を計算
                const damageChange = prevData ? data.damage - prevData.damage : 0;
                const syncChange = prevData ? data.syncLevel - prevData.syncLevel : 0;

                // 変化のクラスを決定
                const damageClass = damageChange > 0 ? 'growth-positive' :
                                  damageChange < 0 ? 'growth-negative' : 'growth-neutral';
                const syncClass = syncChange > 0 ? 'growth-positive' :
                                syncChange < 0 ? 'growth-negative' : 'growth-neutral';

                return `
                    <tr>
                        <td><strong>${data.month}</strong></td>
                        <td>${formatDamage(data.damage)}</td>
                        <td class="${damageClass}">
                            ${prevData ? (damageChange >= 0 ? '+' : '') + formatDamage(damageChange) : '-'}
                        </td>
                        <td>${data.syncLevel}</td>
                        <td class="${syncClass}">
                            ${prevData ? (syncChange >= 0 ? '+' : '') + syncChange : '-'}
                        </td>
                    </tr>
                `;
            }).join('');
        }

        function renderPlayerCharts(monthlyData, playerName) {
            const sortedData = monthlyData.sort((a, b) => a.month.localeCompare(b.month));
            const labels = sortedData.map(d => d.month);
            const damages = sortedData.map(d => d.damage);
            const syncLevels = sortedData.map(d => d.syncLevel);

            // テーマを取得
            const isDarkMode = document.body.getAttribute('data-theme') === 'dark';
            const textColor = isDarkMode ? '#ffffff' : '#475569';

            // ダメージチャートを描画
            const damageCtx = document.getElementById('playerDamageChart').getContext('2d');
            playerDamageChart = new Chart(damageCtx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'ダメージ',
                        data: damages.map(d => d / 10000), // 万単位で表示
                        borderColor: '#3b82f6',
                        backgroundColor: 'rgba(59, 130, 246, 0.1)',
                        borderWidth: 3,
                        fill: true,
                        tension: 0.3,
                        pointBackgroundColor: '#3b82f6',
                        pointBorderColor: '#ffffff',
                        pointBorderWidth: 2,
                        pointRadius: 6,
                        pointHoverRadius: 8
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: false,
                            ticks: {
                                color: textColor,
                                callback: function(value) {
                                    return value.toFixed(0) + '万';
                                }
                            },
                            grid: {
                                color: isDarkMode ? '#374151' : '#e5e7eb'
                            }
                        },
                        x: {
                            ticks: {
                                color: textColor
                            },
                            grid: {
                                color: isDarkMode ? '#374151' : '#e5e7eb'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return formatDamage(damages[context.dataIndex]);
                                }
                            }
                        }
                    },
                    elements: {
                        point: {
                            hoverBackgroundColor: '#3b82f6'
                        }
                    }
                }
            });

            // シンクロレベルチャートを描画
            const syncCtx = document.getElementById('playerSyncChart').getContext('2d');
            playerSyncChart = new Chart(syncCtx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'シンクロレベル',
                        data: syncLevels,
                        borderColor: '#22c55e',
                        backgroundColor: 'rgba(34, 197, 94, 0.1)',
                        borderWidth: 3,
                        fill: true,
                        tension: 0.3,
                        pointBackgroundColor: '#22c55e',
                        pointBorderColor: '#ffffff',
                        pointBorderWidth: 2,
                        pointRadius: 6,
                        pointHoverRadius: 8
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: false,
                            ticks: {
                                color: textColor,
                                callback: function(value) {
                                    return value.toFixed(0);
                                }
                            },
                            grid: {
                                color: isDarkMode ? '#374151' : '#e5e7eb'
                            }
                        },
                        x: {
                            ticks: {
                                color: textColor
                            },
                            grid: {
                                color: isDarkMode ? '#374151' : '#e5e7eb'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        }
                    },
                    elements: {
                        point: {
                            hoverBackgroundColor: '#22c55e'
                        }
                    }
                }
            });
        }

        // モーダルの外側をクリックした時に閉じる
        document.addEventListener('click', function(e) {
            // 自動抽出中はモーダルを閉じない
            if (isAutoExtracting) {
                console.log('⚠️ 自動抽出中のため、モーダルの外側クリックを無視');
                return;
            }

            const playerModal = document.getElementById('playerModal');
            const unionRankModal = document.getElementById('unionRankModal');

            if (e.target === playerModal) {
                hidePlayerDetails();
            }

            if (e.target === unionRankModal) {
                hideUnionRankTrend();
            }
        });

        // ESCキーでモーダルを閉じる
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                // 表示されているモーダルを閉じる
                const playerModal = document.getElementById('playerModal');
                const unionRankModal = document.getElementById('unionRankModal');

                if (playerModal.style.display === 'flex') {
                    hidePlayerDetails();
                } else if (unionRankModal.style.display === 'flex') {
                    hideUnionRankTrend();
                }
            }
        });

        // ユニオン順位関連機能
        let unionRankChart = null;

        function setUnionRank() {
            const rankInput = document.getElementById('unionRankInput');
            const rank = parseFloat(rankInput.value);

            if (!rank || rank <= 0 || rank > 100) {
                alert('1-100の間の数値を入力してください');
                return;
            }

            currentUnionRank = rank;

            // 現在の月を取得
            const currentMonth = getCurrentMonth();

            // ユニオン順位履歴に追加
            if (!unionRankHistory[currentMonth]) {
                unionRankHistory[currentMonth] = {};
            }

            unionRankHistory[currentMonth] = {
                rank: rank,
                totalDamage: processedData.reduce((sum, p) => sum + p.damage, 0),
                date: new Date().toISOString().slice(0, 10)
            };

            // ローカルストレージに保存
            localStorage.setItem('nikke-union-rank-history', JSON.stringify(unionRankHistory));
            localStorage.setItem('nikke-current-union-rank', rank.toString());

            // UIを更新
            updateStats();
            document.getElementById('unionRankStatus').textContent = `✅ ${rank}% に設定されました`;
            rankInput.value = '';

            setTimeout(() => {
                document.getElementById('unionRankStatus').textContent = '';
            }, 3000);
        }

        function showUnionRankTrend() {
            if (Object.keys(unionRankHistory).length === 0 && !currentUnionRank) {
                alert('ユニオン順位のデータがありません。まず順位を設定してください。');
                return;
            }

            // モーダルを表示
            document.getElementById('unionRankModal').style.display = 'flex';

            // モーダルの内容をトップにスクロール
            const modalContent = document.querySelector('#unionRankModal .modal-content');
            if (modalContent) {
                modalContent.scrollTop = 0;
            }

            // 履歴テーブルを描画
            renderUnionRankHistoryTable();

            // グラフを描画（少し遅延して実行）
            setTimeout(() => {
                renderUnionRankChart();
            }, 100);
        }

        function hideUnionRankTrend() {
            document.getElementById('unionRankModal').style.display = 'none';

            // 既存のチャートを破棄
            if (unionRankChart) {
                unionRankChart.destroy();
                unionRankChart = null;
            }
        }

        function renderUnionRankHistoryTable() {
            const tbody = document.getElementById('unionRankHistoryTableBody');
            const allMonths = Object.keys(unionRankHistory).sort();

            // 現在の月のデータも含める
            const currentMonth = getCurrentMonth();
            if (currentUnionRank && !unionRankHistory[currentMonth]) {
                allMonths.push(currentMonth);
            }

            tbody.innerHTML = allMonths.map((month, index) => {
                let data;
                if (month === currentMonth && currentUnionRank) {
                    data = {
                        rank: currentUnionRank,
                        totalDamage: processedData.reduce((sum, p) => sum + p.damage, 0)
                    };
                } else {
                    data = unionRankHistory[month];
                }

                if (!data) return '';

                const prevData = index > 0 ? unionRankHistory[allMonths[index - 1]] : null;
                const rankChange = prevData ? data.rank - prevData.rank : 0;

                // 順位変化のクラス（順位は小さいほど良いので逆転）
                const rankClass = rankChange < 0 ? 'growth-positive' :
                                 rankChange > 0 ? 'growth-negative' : 'growth-neutral';

                return `
                    <tr>
                        <td><strong>${month}</strong></td>
                        <td>${data.rank}%</td>
                        <td class="${rankClass}">
                            ${prevData ?
                                (rankChange <= 0 ?
                                    (rankChange === 0 ? '±0' : `${rankChange.toFixed(2)}% ⬆`) :
                                    `+${rankChange.toFixed(2)}% ⬇`)
                                : '-'}
                        </td>
                        <td>${formatDamage(data.totalDamage)}</td>
                    </tr>
                `;
            }).join('');
        }

        function renderUnionRankChart() {
            const allMonths = Object.keys(unionRankHistory).sort();
            const currentMonth = getCurrentMonth();

            // 現在の月のデータも含める
            if (currentUnionRank && !unionRankHistory[currentMonth]) {
                allMonths.push(currentMonth);
            }

            const labels = allMonths;
            const ranks = allMonths.map(month => {
                if (month === currentMonth && currentUnionRank) {
                    return currentUnionRank;
                }
                return unionRankHistory[month]?.rank || null;
            });

            // テーマを取得
            const isDarkMode = document.body.getAttribute('data-theme') === 'dark';
            const textColor = isDarkMode ? '#ffffff' : '#475569';

            // ユニオン順位チャートを描画
            const ctx = document.getElementById('unionRankChart').getContext('2d');
            unionRankChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'ユニオン順位 (%)',
                        data: ranks,
                        borderColor: '#f59e0b',
                        backgroundColor: 'rgba(245, 158, 11, 0.1)',
                        borderWidth: 4,
                        fill: true,
                        tension: 0.3,
                        pointBackgroundColor: '#f59e0b',
                        pointBorderColor: '#ffffff',
                        pointBorderWidth: 3,
                        pointRadius: 8,
                        pointHoverRadius: 10
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: false,
                            reverse: true, // Y軸を反転（小さい値が上に）
                            ticks: {
                                color: textColor,
                                callback: function(value) {
                                    return value + '%';
                                }
                            },
                            grid: {
                                color: isDarkMode ? '#374151' : '#e5e7eb'
                            },
                            title: {
                                display: true,
                                text: '順位 (% - 上に行くほど良い順位)',
                                color: textColor
                            }
                        },
                        x: {
                            ticks: {
                                color: textColor
                            },
                            grid: {
                                color: isDarkMode ? '#374151' : '#e5e7eb'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `順位: ${context.parsed.y}%`;
                                }
                            }
                        }
                    },
                    elements: {
                        point: {
                            hoverBackgroundColor: '#f59e0b'
                        }
                    }
                }
            });
        }

        // ========================================
        // テーマカラー設定
        // ========================================

        function changeColorTheme(theme) {
            // :root要素にdata-color-theme属性を設定
            document.documentElement.setAttribute('data-color-theme', theme);

            // localStorageに保存
            localStorage.setItem('nikke-color-theme', theme);

            // ボタンのアクティブ状態を更新
            document.querySelectorAll('.theme-color-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.getAttribute('data-theme') === theme) {
                    btn.classList.add('active');
                }
            });

            console.log('テーマカラーを変更:', theme);
            showNotification(`テーマカラーを${getThemeName(theme)}に変更しました`, 'info');
        }

        function getThemeName(theme) {
            const names = {
                'purple': 'パープル',
                'blue': 'ブルー',
                'teal': 'ティール',
                'green': 'グリーン',
                'red': 'レッド',
                'orange': 'オレンジ'
            };
            return names[theme] || theme;
        }

        function loadColorTheme() {
            const savedTheme = localStorage.getItem('nikke-color-theme') || 'purple';
            document.documentElement.setAttribute('data-color-theme', savedTheme);

            // ボタンのアクティブ状態を更新
            document.querySelectorAll('.theme-color-btn').forEach(btn => {
                if (btn.getAttribute('data-theme') === savedTheme) {
                    btn.classList.add('active');
                }
            });

            console.log('保存されたテーマカラーを読み込み:', savedTheme);
        }

        // ページ読み込み時にユニオン順位データを復元
        function loadUnionRankData() {
            const savedRank = localStorage.getItem('nikke-current-union-rank');
            const savedHistory = localStorage.getItem('nikke-union-rank-history');

            if (savedRank) {
                currentUnionRank = parseFloat(savedRank);
            }

            if (savedHistory) {
                try {
                    unionRankHistory = JSON.parse(savedHistory);
                } catch (error) {
                    console.error('ユニオン順位履歴の読み込みに失敗:', error);
                    unionRankHistory = {};
                }
            }
        }

        // ========================================
        // Phase 3: 共有履歴システム (data/history.json)
        // ========================================

        // 共有履歴データを自動読み込み
        async function autoLoadHistory() {
            try {
                const response = await fetch('./data/history.json');
                if (response.ok) {
                    const sharedHistory = await response.json();
                    console.log('✅ 共有履歴データを読み込みました:', sharedHistory);

                    // localStorageの履歴を読み込み
                    const localHistoryJson = localStorage.getItem('nikke-analytics-history');
                    let localHistory = {};
                    if (localHistoryJson) {
                        try {
                            localHistory = JSON.parse(localHistoryJson);
                        } catch (e) {
                            console.warn('localStorage履歴の解析に失敗:', e);
                        }
                    }

                    // 統合処理
                    const mergedHistory = mergeHistoryData(sharedHistory.months || {}, localHistory);
                    historyData = mergedHistory;

                    // ユニオン順位履歴も統合
                    if (sharedHistory.unionRankHistory) {
                        unionRankHistory = {
                            ...sharedHistory.unionRankHistory,
                            ...unionRankHistory  // localStorageを優先
                        };
                    }

                    // localStorageに保存
                    localStorage.setItem('nikke-analytics-history', JSON.stringify(historyData));

                    console.log('✅ 履歴を統合しました（shared + local）:', Object.keys(historyData).length, 'ヶ月');
                    showNotification(`共有履歴を読み込みました（${Object.keys(historyData).length}ヶ月）`, 'success');
                } else {
                    console.log('history.jsonが見つかりません（任意）');
                }
            } catch (error) {
                console.log('history.json読み込みエラー（任意のため続行）:', error.message);
            }
        }

        // 共有履歴とローカル履歴をマージ
        function mergeHistoryData(sharedMonths, localMonths) {
            const merged = { ...sharedMonths };

            for (const [monthKey, localData] of Object.entries(localMonths)) {
                if (merged[monthKey]) {
                    // 既存の場合、日付を比較して新しい方を採用
                    const sharedDate = getHistoryDate(merged[monthKey]);
                    const localDate = getHistoryDate(localData);

                    if (localDate > sharedDate) {
                        console.log(`月 ${monthKey}: ローカルデータが新しいため採用`);
                        merged[monthKey] = localData;
                    } else {
                        console.log(`月 ${monthKey}: 共有データが新しいため採用`);
                    }
                } else {
                    // 新しい月の場合はそのまま追加
                    merged[monthKey] = localData;
                }
            }

            return merged;
        }

        // 履歴データから日付を取得
        function getHistoryDate(data) {
            if (Array.isArray(data) && data.length > 0) {
                return new Date(data[0].date || '2000-01-01');
            }
            return new Date('2000-01-01');
        }

        // 共有履歴JSONを生成してダウンロード
        function exportSharedHistory() {
            if (Object.keys(historyData).length === 0) {
                alert('履歴データがありません。先に「データ蓄積」を実行してください。');
                return;
            }

            const sharedHistory = {
                version: "1.0",
                lastUpdated: new Date().toISOString(),
                description: "しりすこPAD 共有履歴データ - メンバー全員で同じ履歴を共有できます",
                months: historyData,
                unionRankHistory: unionRankHistory
            };

            const json = JSON.stringify(sharedHistory, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.href = url;
            link.download = 'history.json';
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            showNotification('history.json を生成しました！', 'success');
        }

        // ページ読み込み時にユニオン順位データを読み込み
        document.addEventListener('DOMContentLoaded', function() {
            loadColorTheme();        // テーマカラーを読み込み
            loadUnionRankData();
            autoLoadHistory();     // 共有履歴を自動読み込み
            loadAvailableArchives(); // 過去データタブ用: 利用可能なアーカイブを読み込み

            // URL経由でのJSON自動読み込み
            autoLoadJSONFromURL();
            updateCurrentDataInfo(); // 現在表示中のデータ情報を更新
        });

        // URL経由でのJSON自動読み込み機能
        async function autoLoadJSONFromURL() {
            const urlParams = new URLSearchParams(window.location.search);
            const monthParam = urlParams.get('month');
            const dataParam = urlParams.get('data');

            let jsonUrl = null;

            // monthパラメータがある場合
            if (monthParam) {
                jsonUrl = `./data/${monthParam}.json`;
            }
            // dataパラメータがある場合（カスタムURL）
            else if (dataParam) {
                jsonUrl = dataParam;
            }
            // デフォルトでlatest.jsonを読み込む
            else {
                jsonUrl = './data/latest.json';
            }

            // JSONファイルを自動読み込み
            try {
                console.log('JSON自動読み込み開始:', jsonUrl);
                const response = await fetch(jsonUrl);

                if (!response.ok) {
                    // latest.jsonが見つからない場合は何もしない（手動アップロード待ち）
                    if (jsonUrl.includes('latest.json')) {
                        console.log('latest.jsonが見つかりません。手動アップロードをお待ちください。');
                        return;
                    }
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const jsonText = await response.text();
                rawData = JSON.parse(jsonText);

                console.log('JSON自動読み込み完了:', rawData);

                // データ処理と表示
                processData();
                showResults();

            } catch (error) {
                console.error('JSON自動読み込みエラー:', error);
                // エラーは表示せず、手動アップロードを待つ
                if (!jsonUrl.includes('latest.json')) {
                    showError('指定されたデータファイルの読み込みに失敗しました: ' + error.message);
                }
            }
        }

        // ========================================
        // 過去データ閲覧タブ機能
        // ========================================

        let availableArchives = [];
        let currentDataSource = 'latest'; // 'latest' or アーカイブの月 (例: '2026-01')

        // 利用可能なアーカイブファイルを検出
        async function loadAvailableArchives() {
            const select = document.getElementById('archiveMonthSelect');
            if (!select) return;

            // 既知のアーカイブパターン（2020年から2030年まで）
            const archives = [];
            for (let year = 2024; year <= 2026; year++) {
                for (let month = 1; month <= 12; month++) {
                    const monthKey = `${year}-${String(month).padStart(2, '0')}`;
                    archives.push({
                        file: `${monthKey}.json`,
                        year: year,
                        month: month,
                        label: `${year}年${month}月`
                    });
                }
            }

            // 実際に存在するアーカイブを確認
            availableArchives = [];
            for (const archive of archives) {
                try {
                    const response = await fetch(`./data/${archive.file}`, { method: 'HEAD' });
                    if (response.ok) {
                        availableArchives.push(archive);
                    }
                } catch (error) {
                    // ファイルが存在しない場合はスキップ
                }
            }

            // ドロップダウンに追加（新しい順）
            availableArchives.sort((a, b) => b.year * 100 + b.month - (a.year * 100 + a.month));
            select.innerHTML = '<option value="">月を選択してください</option>';
            availableArchives.forEach(archive => {
                const option = document.createElement('option');
                option.value = archive.file.replace('.json', '');
                option.textContent = archive.label;
                select.appendChild(option);
            });

            console.log('利用可能なアーカイブ:', availableArchives.length, '件');
        }

        // アーカイブデータを読み込む
        async function loadArchiveData() {
            const select = document.getElementById('archiveMonthSelect');
            const statusEl = document.getElementById('archiveStatus');
            const monthKey = select.value;

            if (!monthKey) {
                alert('月を選択してください');
                return;
            }

            try {
                statusEl.style.display = 'block';
                statusEl.style.background = 'var(--md-sys-color-secondary-container)';
                statusEl.style.color = 'var(--md-sys-color-on-secondary-container)';
                statusEl.textContent = '📥 データを読み込み中...';

                const response = await fetch(`./data/${monthKey}.json`);
                if (!response.ok) {
                    throw new Error(`ファイルが見つかりません: ${monthKey}.json`);
                }

                const jsonText = await response.text();
                rawData = JSON.parse(jsonText);

                // データ処理と表示
                processData();
                showResults();

                // 表示タブに切り替え
                switchTab('ranking');

                currentDataSource = monthKey;
                updateCurrentDataInfo();

                statusEl.style.background = 'var(--md-sys-color-primary-container)';
                statusEl.style.color = 'var(--md-sys-color-on-primary-container)';
                statusEl.textContent = `✅ ${monthKey} のデータを読み込みました`;

                showNotification(`${monthKey} のデータを読み込みました`, 'success');

                setTimeout(() => {
                    statusEl.style.display = 'none';
                }, 3000);

            } catch (error) {
                console.error('アーカイブ読み込みエラー:', error);
                statusEl.style.background = 'var(--md-sys-color-error-container)';
                statusEl.style.color = 'var(--md-sys-color-on-error-container)';
                statusEl.textContent = `❌ エラー: ${error.message}`;
                showNotification('データの読み込みに失敗しました', 'error');
            }
        }

        // 最新データに戻る
        async function backToLatest() {
            try {
                const statusEl = document.getElementById('archiveStatus');
                statusEl.style.display = 'block';
                statusEl.style.background = 'var(--md-sys-color-secondary-container)';
                statusEl.style.color = 'var(--md-sys-color-on-secondary-container)';
                statusEl.textContent = '📥 最新データを読み込み中...';

                const response = await fetch('./data/latest.json');
                if (!response.ok) {
                    throw new Error('latest.jsonが見つかりません');
                }

                const jsonText = await response.text();
                rawData = JSON.parse(jsonText);

                processData();
                showResults();
                switchTab('ranking');

                currentDataSource = 'latest';
                updateCurrentDataInfo();

                statusEl.style.background = 'var(--md-sys-color-primary-container)';
                statusEl.style.color = 'var(--md-sys-color-on-primary-container)';
                statusEl.textContent = '✅ 最新データを読み込みました';

                showNotification('最新データを読み込みました', 'success');

                setTimeout(() => {
                    statusEl.style.display = 'none';
                }, 3000);

            } catch (error) {
                console.error('最新データ読み込みエラー:', error);
                showNotification('最新データの読み込みに失敗しました', 'error');
            }
        }

        // 現在表示中のデータ情報を更新
        function updateCurrentDataInfo() {
            const infoEl = document.getElementById('currentDataInfo');
            if (!infoEl) return;

            if (!rawData || !processedData || processedData.length === 0) {
                infoEl.innerHTML = '<p style="color: var(--md-sys-color-on-surface-variant);">データが読み込まれていません</p>';
                return;
            }

            const metadata = rawData.metadata || {};
            const extractedDate = metadata.extractedAt ? new Date(metadata.extractedAt).toLocaleDateString('ja-JP') : '不明';
            const playerCount = processedData.length;
            const totalDamage = processedData.reduce((sum, p) => sum + p.damage, 0);
            const unionRank = currentUnionRank ? `${currentUnionRank}%` : '未設定';

            let dataSourceLabel = '';
            if (currentDataSource === 'latest') {
                dataSourceLabel = '<span style="background: var(--md-sys-color-primary); color: var(--md-sys-color-on-primary); padding: 4px 12px; border-radius: 12px; font-size: 12px; font-weight: 500;">📊 最新データ</span>';
            } else {
                const archive = availableArchives.find(a => a.file.replace('.json', '') === currentDataSource);
                const label = archive ? archive.label : currentDataSource;
                dataSourceLabel = `<span style="background: var(--md-sys-color-secondary); color: var(--md-sys-color-on-secondary); padding: 4px 12px; border-radius: 12px; font-size: 12px; font-weight: 500;">📂 ${label}</span>`;
            }

            infoEl.innerHTML = `
                <div style="display: flex; flex-direction: column; gap: 12px;">
                    <div style="display: flex; align-items: center; gap: 12px;">
                        ${dataSourceLabel}
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 16px;">
                        <div>
                            <div style="font-size: 12px; color: var(--md-sys-color-on-surface-variant); margin-bottom: 4px;">抽出日</div>
                            <div style="font-size: 16px; font-weight: 500; color: var(--md-sys-color-on-surface);">${extractedDate}</div>
                        </div>
                        <div>
                            <div style="font-size: 12px; color: var(--md-sys-color-on-surface-variant); margin-bottom: 4px;">参加者数</div>
                            <div style="font-size: 16px; font-weight: 500; color: var(--md-sys-color-on-surface);">${playerCount}人</div>
                        </div>
                        <div>
                            <div style="font-size: 12px; color: var(--md-sys-color-on-surface-variant); margin-bottom: 4px;">総ダメージ</div>
                            <div style="font-size: 16px; font-weight: 500; color: var(--md-sys-color-on-surface);">${formatDamage(totalDamage)}</div>
                        </div>
                        <div>
                            <div style="font-size: 12px; color: var(--md-sys-color-on-surface-variant); margin-bottom: 4px;">ユニオン順位</div>
                            <div style="font-size: 16px; font-weight: 500; color: var(--md-sys-color-on-surface);">${unionRank}</div>
                        </div>
                    </div>
                </div>
            `;
        }

        // 固定データHTML生成機能
        // Blob to Base64変換ヘルパー関数
        function blobToBase64(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        }

        async function exportStandaloneHTML() {
            if (!processedData || processedData.length === 0) {
                alert('データが読み込まれていません。先にJSONファイルをアップロードしてください。');
                return;
            }

            // 現在の状態を固定データとして生成
            const currentDate = new Date().toISOString().slice(0, 10);
            const monthName = rawData.raidData?.month || currentDate.slice(0, 7);

            // 画像埋め込み処理中のメッセージ
            const originalButton = event.target;
            const originalText = originalButton.textContent;
            originalButton.textContent = '生成中...';
            originalButton.disabled = true;

            try {
                const standaloneHTML = await createSimpleShareableHTML(processedData, historyData, unionRankHistory, currentUnionRank, monthName);

                // ダウンロード
                const blob = new Blob([standaloneHTML], { type: 'text/html;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `nikke-analytics-standalone-${monthName}.html`;
                a.click();
                URL.revokeObjectURL(url);

                alert('固定データHTMLファイルが作成されました！\n\nファイル名: nikke-analytics-standalone-' + monthName + '.html');
            } catch (error) {
                console.error('HTML生成エラー:', error);
                alert('HTMLファイルの生成に失敗しました: ' + error.message);
            } finally {
                originalButton.textContent = originalText;
                originalButton.disabled = false;
            }
        }

        // 共有用HTML作成 - データ埋め込み＆不要機能削除版
        async function createSimpleShareableHTML(players, historyData, unionRankHistory, currentUnionRank, monthName) {
            // 既存のHTMLを基本としてコピー
            let html = document.documentElement.outerHTML;

            // 背景画像をBase64に変換して埋め込む
            try {
                const bgImageResponse = await fetch('./しりすこPADヘッダー.PNG');
                const bgImageBlob = await bgImageResponse.blob();
                const bgImageBase64 = await blobToBase64(bgImageBlob);
                html = html.replace(/url\(['"]?\.\/しりすこPADヘッダー\.PNG['"]?\)/g, `url(${bgImageBase64})`);
            } catch (e) {
                console.warn('背景画像の埋め込みに失敗しました:', e);
            }

            // 属性アイコンをBase64に変換して埋め込む
            const attributeIcons = ['灼熱.png', '水冷.png', '電撃.png', '鉄甲.png', '風圧.png'];
            for (const icon of attributeIcons) {
                try {
                    const iconResponse = await fetch(`./属性アイコン/${icon}`);
                    const iconBlob = await iconResponse.blob();
                    const iconBase64 = await blobToBase64(iconBlob);
                    const regex = new RegExp(`(['"])\\.\\/属性アイコン\\/${icon}\\1`, 'g');
                    html = html.replace(regex, `$1${iconBase64}$1`);
                } catch (e) {
                    console.warn(`属性アイコン ${icon} の埋め込みに失敗しました:`, e);
                }
            }

            // タイトル変更
            html = html.replace(/<title>.*?<\/title>/, '<title>しりすこPAD - ' + monthName + ' (共有版)</title>');

            // ヘッダー変更
            html = html.replace('しりすこPAD', 'しりすこPAD - ' + monthName + ' (共有版)');

            // 入力系の要素を全て削除（共有版では不要）
            html = html.replace(/<div class="upload-container">[\s\S]*?<\/div>/g, '');
            html = html.replace(/<div class="union-input-container">[\s\S]*?<\/div>/g, '');
            html = html.replace(/<button[^>]*onclick="exportStandaloneHTML\(\)"[^>]*>[\s\S]*?<\/button>/g, '');

            // JSONファイルアップロード機能を削除
            html = html.replace(/<div class="card">\s*<div class="upload-area"[\s\S]*?<\/div>\s*<\/div>/g, '');

            // JSONファイルアップロード関連のCSS削除
            html = html.replace(/\.upload-area\s*{[\s\S]*?}/g, '');
            html = html.replace(/\.upload-area:hover\s*{[\s\S]*?}/g, '');
            html = html.replace(/\.upload-area\.dragover\s*{[\s\S]*?}/g, '');
            html = html.replace(/\.upload-area\s+h3\s*{[\s\S]*?}/g, '');
            html = html.replace(/\.upload-area\s+p\s*{[\s\S]*?}/g, '');
            html = html.replace(/\.upload-area\s+small\s*{[\s\S]*?}/g, '');
            html = html.replace(/#fileInput\s*{[\s\S]*?}/g, '');

            // JSONファイルアップロード関連のJavaScript削除
            html = html.replace(/\/\/ ファイルアップロード処理[\s\S]*?(?=function processData|$)/g, '');

            // 配布用では不要な編集機能を削除
            html = html.replace(/<button[^>]*onclick="toggleDebug\(\)"[^>]*>[\s\S]*?<\/button>/g, '');
            html = html.replace(/<button[^>]*onclick="showSyncLevelEditor\(\)"[^>]*>[\s\S]*?<\/button>/g, '');
            html = html.replace(/<button[^>]*onclick="exportUpdatedJSON\(\)"[^>]*>[\s\S]*?<\/button>/g, '');
            html = html.replace(/<button[^>]*onclick="accumulateData\(\)"[^>]*>[\s\S]*?<\/button>/g, '');

            // ユニオン順位設定エリアを削除
            html = html.replace(/<div class="union-rank-setting card"[\s\S]*?<\/div>/g, '');

            // 設定ボタンも個別に削除（念のため）
            html = html.replace(/<button[^>]*onclick="setUnionRank\(\)"[^>]*>[\s\S]*?<\/button>/g, '');

            // 入力関連のスペースを削除し、見やすさを向上
            html = html.replace(/(<body[^>]*>)\s*(<div class="container">)/g, '$1\n$2');

            // 共有版であることを明示するスタイルを追加
            const shareStyle = '<style>.container{margin-top:20px!important;}</style>';
            html = html.replace('</head>', shareStyle + '</head>');

            // データを安全に埋め込む
            const dataScript = document.createElement('script');
            dataScript.textContent = `
                document.addEventListener("DOMContentLoaded", function() {
                    // 固定データを設定
                    processedData = ${JSON.stringify(players)};
                    historyData = ${JSON.stringify(historyData)};
                    unionRankHistory = ${JSON.stringify(unionRankHistory)};
                    currentUnionRank = ${currentUnionRank};
                    rawData = { raidData: { month: "${monthName}" } };

                    // フィルタデータも設定（グラフ生成に必要）
                    filteredData = processedData.slice();

                    // 重要：成長データを生成（個人詳細表示に必要）
                    if (typeof generateGrowthData === 'function') {
                        generateGrowthData();
                    }

                    // 初期化処理を実行
                    if (typeof generateGrowthData === 'function') {
                        generateGrowthData();
                    }
                    if (typeof analyzeTeamCompositions === 'function') {
                        analyzeTeamCompositions();
                    }
                    if (typeof updateStats === 'function') {
                        updateStats();
                    }
                    if (typeof updateTable === 'function') {
                        updateTable();
                    }
                    if (typeof createAttributeStackedBarChart === 'function') {
                        createAttributeStackedBarChart(processedData);
                    }
                    if (typeof createSLvComparisonChart === 'function') {
                        createSLvComparisonChart(processedData);
                    }
                    if (typeof renderSlvEfficiencyRanking === 'function') {
                        renderSlvEfficiencyRanking(processedData);
                    }
                    if (typeof loadUnionRankData === 'function') {
                        loadUnionRankData();
                    }

                    // 結果エリアを表示
                    const results = document.getElementById('results');
                    if (results) {
                        results.style.display = 'block';
                    }
                });
            `;

            html = html.replace('</head>', dataScript.outerHTML + '</head>');

            return html;
        }

        // ========================================
        // Phase 2: データエクスポート機能
        // ========================================

        function showExportMenu() {
            if (!processedData || processedData.length === 0) {
                alert('エクスポートするデータがありません。先にJSONファイルをアップロードしてください。');
                return;
            }
            document.getElementById('exportModal').style.display = 'flex';
        }

        function closeExportMenu() {
            document.getElementById('exportModal').style.display = 'none';
        }

        function exportToCSV() {
            if (!processedData || processedData.length === 0) {
                alert('エクスポートするデータがありません。');
                return;
            }

            // CSVヘッダー
            let csv = '\uFEFF'; // BOM for UTF-8
            csv += 'ランク,プレイヤー名,総ダメージ,前回からの増加,SLv,最大攻撃力,平均攻撃力,攻撃回数,使用キャラクター\n';

            // データ行
            processedData.forEach((player, index) => {
                const characters = player.characterNames ? player.characterNames.join(';') : '';
                csv += `${index + 1},"${player.name}",${player.damage},${player.growth || 0},${player.syncLevel || 0},${player.maxAttack || 0},${player.avgAttack || 0},${player.attackCount || 0},"${characters}"\n`;
            });

            // ダウンロード
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            const date = new Date().toISOString().slice(0, 10);
            link.setAttribute('href', url);
            link.setAttribute('download', `しりすこPAD_データ_${date}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            closeExportMenu();
            alert('CSVファイルをエクスポートしました！');
        }

        function exportToJSON() {
            if (!processedData || processedData.length === 0) {
                alert('エクスポートするデータがありません。');
                return;
            }

            const exportData = {
                exportDate: new Date().toISOString(),
                playerCount: processedData.length,
                unionRank: currentUnionRank,
                players: processedData
            };

            const json = JSON.stringify(exportData, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            const date = new Date().toISOString().slice(0, 10);
            link.setAttribute('href', url);
            link.setAttribute('download', `しりすこPAD_データ_${date}.json`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            closeExportMenu();
            alert('JSONファイルをエクスポートしました！');
        }

        function exportHistoryToJSON() {
            const historyKeys = Object.keys(historyData);
            if (historyKeys.length === 0) {
                alert('履歴データがありません。先に「データ蓄積」を実行してください。');
                return;
            }

            const exportData = {
                exportDate: new Date().toISOString(),
                monthCount: historyKeys.length,
                months: historyKeys,
                historyData: historyData,
                unionRankHistory: unionRankHistory
            };

            const json = JSON.stringify(exportData, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            const date = new Date().toISOString().slice(0, 10);
            link.setAttribute('href', url);
            link.setAttribute('download', `しりすこPAD_履歴バックアップ_${date}.json`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            closeExportMenu();
            alert('履歴データをバックアップしました！');
        }

        // ========================================
        // Phase 2: 月別アーカイブ機能
        // ========================================

        function exportMonthlyArchive() {
            if (!rawData || !processedData || processedData.length === 0) {
                alert('データが読み込まれていません。先にJSONファイルを読み込んでください。');
                return;
            }
            showMonthlyArchiveModal();
        }

        function showMonthlyArchiveModal() {
            const modal = document.getElementById('monthlyArchiveModal');
            modal.style.display = 'flex';

            // デフォルト値を現在の日付に設定
            const now = new Date();
            document.getElementById('archiveYearInput').value = now.getFullYear();
            document.getElementById('archiveMonthInput').value = now.getMonth() + 1;
        }

        function closeMonthlyArchiveModal() {
            document.getElementById('monthlyArchiveModal').style.display = 'none';
        }

        function confirmMonthlyArchive() {
            const year = parseInt(document.getElementById('archiveYearInput').value);
            const month = parseInt(document.getElementById('archiveMonthInput').value);

            // 入力値の検証
            if (!year || year < 2020 || year > 2030) {
                alert('正しい年を入力してください（2020-2030）');
                return;
            }
            if (!month || month < 1 || month > 12) {
                alert('正しい月を入力してください（1-12）');
                return;
            }

            const monthKey = `${year}-${String(month).padStart(2, '0')}`;

            // rawDataのコピーを作成してアーカイブメタデータを追加
            const archiveData = JSON.parse(JSON.stringify(rawData));
            if (!archiveData.metadata) {
                archiveData.metadata = {};
            }
            archiveData.metadata.archiveMonth = monthKey;
            archiveData.metadata.archivedAt = new Date().toISOString();

            // ユニオン順位を含める（既にmetadataにある場合はそのまま、なければcurrentUnionRankから）
            if (archiveData.metadata.unionRank === undefined || archiveData.metadata.unionRank === null) {
                if (currentUnionRank) {
                    archiveData.metadata.unionRank = currentUnionRank;
                }
            }

            // JSONファイルとしてダウンロード
            const json = JSON.stringify(archiveData, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.href = url;
            link.download = `${monthKey}.json`;
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            closeMonthlyArchiveModal();

            showNotification(`${monthKey}.json として保存しました！`, 'success');
        }

        // ========================================
        // Phase 2: フィルター & ソート機能
        // ========================================

        let currentSortField = 'rank';
        let currentSortOrder = 'asc';

        function applyFilters() {
            if (!processedData || processedData.length === 0) {
                return;
            }

            const searchText = document.getElementById('playerSearchInput').value.toLowerCase();
            const minDamage = parseInt(document.getElementById('minDamageInput').value) || 0;
            const minSlv = parseInt(document.getElementById('minSlvInput').value) || 0;
            const sortField = document.getElementById('sortSelect').value;

            // フィルタリング
            let filtered = processedData.filter(player => {
                const matchesSearch = player.name.toLowerCase().includes(searchText);
                const matchesDamage = player.damage >= minDamage;
                const matchesSlv = (player.syncLevel || 0) >= minSlv;
                return matchesSearch && matchesDamage && matchesSlv;
            });

            // ソート
            filtered = sortData(filtered, sortField);

            // 表示
            displayFilteredData(filtered);

            // ステータス表示
            const status = document.getElementById('filterStatus');
            if (filtered.length < processedData.length) {
                status.textContent = `${filtered.length} / ${processedData.length} 件表示中`;
            } else {
                status.textContent = `全 ${processedData.length} 件表示中`;
            }
        }

        function sortData(data, field) {
            const sorted = [...data];

            switch(field) {
                case 'rank':
                    sorted.sort((a, b) => processedData.indexOf(a) - processedData.indexOf(b));
                    break;
                case 'damage':
                    sorted.sort((a, b) => b.damage - a.damage);
                    break;
                case 'growth':
                    sorted.sort((a, b) => (b.growth || 0) - (a.growth || 0));
                    break;
                case 'slv':
                    sorted.sort((a, b) => (b.syncLevel || 0) - (a.syncLevel || 0));
                    break;
                case 'name':
                    sorted.sort((a, b) => a.name.localeCompare(b.name, 'ja'));
                    break;
            }

            return sorted;
        }

        function sortBy(field) {
            // Toggle sort order
            if (currentSortField === field) {
                currentSortOrder = currentSortOrder === 'asc' ? 'desc' : 'asc';
            } else {
                currentSortField = field;
                currentSortOrder = 'asc';
            }

            // Update sort indicators
            document.querySelectorAll('[id^="sort-"]').forEach(el => el.textContent = '');
            document.getElementById(`sort-${field}`).textContent = currentSortOrder === 'asc' ? '▲' : '▼';

            // Set the select to match
            document.getElementById('sortSelect').value = field;

            // Apply filters
            applyFilters();
        }

        function displayFilteredData(data) {
            const tbody = document.getElementById('tableBody');
            tbody.innerHTML = '';

            data.forEach((player, index) => {
                const row = tbody.insertRow();
                row.insertCell(0).textContent = processedData.indexOf(player) + 1; // Original rank
                row.insertCell(1).textContent = player.name;
                row.insertCell(2).textContent = player.damage.toLocaleString();
                row.insertCell(3).textContent = player.syncLevel || '-';

                const growthCell = row.insertCell(4);
                if (player.growth) {
                    growthCell.textContent = `+${player.growth.toLocaleString()}`;
                    growthCell.style.color = 'var(--md-sys-color-tertiary)';
                    growthCell.style.fontWeight = '500';
                } else {
                    growthCell.textContent = '-';
                }
            });
        }

        function resetFilters() {
            document.getElementById('playerSearchInput').value = '';
            document.getElementById('minDamageInput').value = '';
            document.getElementById('minSlvInput').value = '';
            document.getElementById('sortSelect').value = 'rank';
            document.querySelectorAll('[id^="sort-"]').forEach(el => el.textContent = '');
            applyFilters();
        }

        // ========================================
        // タブ2: キャラクター使用率分析
        // ========================================

        function displayCharacterGrid(characters) {
            const grid = document.getElementById('characterUsageGrid');
            grid.innerHTML = '';

            characters.slice(0, 20).forEach((char, index) => {
                const card = document.createElement('div');
                card.className = 'stat-card';
                card.style.cursor = 'pointer';
                card.innerHTML = `
                    <div style="display: flex; align-items: center; justify-content: center; margin-bottom: 8px; font-size: 24px;">
                        ${index < 3 ? ['🥇', '🥈', '🥉'][index] : ''}
                    </div>
                    <h3 style="font-size: 14px; margin-bottom: 8px; height: 40px; display: flex; align-items: center; justify-content: center;">
                        ${char.name}
                    </h3>
                    <div class="value" style="font-size: 28px;">${char.count}</div>
                    <small style="color: var(--md-sys-color-on-surface-variant);">使用率 ${char.rate}%</small>
                `;
                card.onclick = () => showCharacterDetail(char);
                grid.appendChild(card);
            });
        }

        function displayCharacterTable(characters) {
            const tbody = document.getElementById('characterUsageTableBody');
            tbody.innerHTML = '';

            characters.forEach((char, index) => {
                const row = tbody.insertRow();
                const rankCell = row.insertCell(0);
                rankCell.textContent = index + 1;
                rankCell.style.textAlign = 'center';
                if (index < 3) {
                    rankCell.innerHTML = ['🥇', '🥈', '🥉'][index] + ' ' + (index + 1);
                }

                row.insertCell(1).textContent = char.name;
                row.insertCell(2).textContent = char.count;
                row.insertCell(3).textContent = char.rate + '%';
                row.insertCell(4).textContent = char.players.length;

                row.style.cursor = 'pointer';
                row.onclick = () => showCharacterDetail(char);
            });
        }

        function showCharacterDetail(char) {
            alert(`${char.name}\n\n使用回数: ${char.count}\n使用率: ${char.rate}%\n使用プレイヤー数: ${char.players.length}\n\n使用プレイヤー:\n${char.players.join(', ')}`);
        }

        function changeCharacterView(view) {
            if (view === 'grid') {
                document.getElementById('characterGridView').style.display = 'block';
                document.getElementById('characterTableView').style.display = 'none';
                document.getElementById('viewGridBtn').classList.add('btn-primary');
                document.getElementById('viewGridBtn').classList.remove('btn-text');
                document.getElementById('viewTableBtn').classList.add('btn-text');
                document.getElementById('viewTableBtn').classList.remove('btn-primary');
            } else {
                document.getElementById('characterGridView').style.display = 'none';
                document.getElementById('characterTableView').style.display = 'block';
                document.getElementById('viewTableBtn').classList.add('btn-primary');
                document.getElementById('viewTableBtn').classList.remove('btn-text');
                document.getElementById('viewGridBtn').classList.add('btn-text');
                document.getElementById('viewGridBtn').classList.remove('btn-primary');
            }
        }

        function analyzeTeamPatterns() {
            if (!processedData || processedData.length === 0) {
                return;
            }

            const teamCombos = new Map();

            processedData.forEach(player => {
                if (player.characterNames && player.characterNames.length >= 2) {
                    // 2キャラクターの組み合わせを集計
                    for (let i = 0; i < player.characterNames.length - 1; i++) {
                        for (let j = i + 1; j < player.characterNames.length; j++) {
                            const char1 = player.characterNames[i];
                            const char2 = player.characterNames[j];
                            const combo = [char1, char2].sort().join(' + ');
                            teamCombos.set(combo, (teamCombos.get(combo) || 0) + 1);
                        }
                    }
                }
            });

            const topCombos = Array.from(teamCombos.entries())
                .map(([combo, count]) => ({ combo, count }))
                .sort((a, b) => b.count - a.count)
                .slice(0, 10);

            const container = document.getElementById('teamPatternsContainer');
            if (topCombos.length === 0) {
                container.innerHTML = '<p style="color: var(--md-sys-color-on-surface-variant); text-align: center; padding: 32px;">組み合わせデータがありません</p>';
                return;
            }

            container.innerHTML = topCombos.map((item, index) => `
                <div style="display: flex; justify-content: space-between; align-items: center; padding: 12px 16px; background: var(--md-sys-color-surface-variant); border-radius: 8px; margin-bottom: 8px;">
                    <div style="display: flex; align-items: center; gap: 12px;">
                        <span style="font-size: 20px; width: 30px;">${index < 3 ? ['🥇', '🥈', '🥉'][index] : index + 1}</span>
                        <span style="font-weight: 500;">${item.combo}</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span style="font-size: 18px; font-weight: 500; color: var(--md-sys-color-primary);">${item.count}</span>
                        <span style="font-size: 12px; color: var(--md-sys-color-on-surface-variant);">回</span>
                    </div>
                </div>
            `).join('');
        }

        // ========================================
        // Phase 2: データ比較機能
        // ========================================

        function showCompareModal() {
            const historyKeys = Object.keys(historyData);
            if (historyKeys.length < 2) {
                alert('比較するには少なくとも2ヶ月分のデータが必要です。');
                return;
            }

            // セレクトボックスに月を追加
            const select1 = document.getElementById('compareMonth1');
            const select2 = document.getElementById('compareMonth2');

            select1.innerHTML = '<option value="">選択してください</option>';
            select2.innerHTML = '<option value="">選択してください</option>';

            historyKeys.sort().forEach(month => {
                select1.innerHTML += `<option value="${month}">${month}</option>`;
                select2.innerHTML += `<option value="${month}">${month}</option>`;
            });

            document.getElementById('compareResults').style.display = 'none';
            document.getElementById('compareModal').style.display = 'flex';
        }

        function closeCompareModal() {
            document.getElementById('compareModal').style.display = 'none';
        }

        function executeCompare() {
            const month1 = document.getElementById('compareMonth1').value;
            const month2 = document.getElementById('compareMonth2').value;

            if (!month1 || !month2) {
                alert('2つの月を選択してください。');
                return;
            }

            if (month1 === month2) {
                alert('異なる月を選択してください。');
                return;
            }

            const data1 = historyData[month1];
            const data2 = historyData[month2];

            // 比較結果を計算
            const comparisonResults = [];
            const playerMap1 = new Map(data1.map(p => [p.name, p]));
            const playerMap2 = new Map(data2.map(p => [p.name, p]));

            // 全プレイヤーを取得
            const allPlayers = new Set([...playerMap1.keys(), ...playerMap2.keys()]);

            allPlayers.forEach(playerName => {
                const p1 = playerMap1.get(playerName);
                const p2 = playerMap2.get(playerName);

                if (p1 && p2) {
                    const damageDiff = p2.damage - p1.damage;
                    const slvDiff = (p2.syncLevel || 0) - (p1.syncLevel || 0);
                    comparisonResults.push({
                        name: playerName,
                        damage1: p1.damage,
                        damage2: p2.damage,
                        damageDiff: damageDiff,
                        damageGrowthRate: ((damageDiff / p1.damage) * 100).toFixed(1),
                        slv1: p1.syncLevel || 0,
                        slv2: p2.syncLevel || 0,
                        slvDiff: slvDiff
                    });
                }
            });

            // 成長率でソート
            comparisonResults.sort((a, b) => b.damageDiff - a.damageDiff);

            // 結果を表示
            displayComparisonResults(comparisonResults, month1, month2);
        }

        function displayComparisonResults(results, month1, month2) {
            const container = document.getElementById('compareResultsContent');

            let html = `
                <div style="background: var(--md-sys-color-surface-variant); padding: 16px; border-radius: 12px; margin-bottom: 16px;">
                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 16px; text-align: center;">
                        <div>
                            <div style="font-size: 12px; color: var(--md-sys-color-on-surface-variant);">基準月</div>
                            <div style="font-size: 18px; font-weight: 500; margin-top: 4px;">${month1}</div>
                        </div>
                        <div>
                            <div style="font-size: 12px; color: var(--md-sys-color-on-surface-variant);">比較先月</div>
                            <div style="font-size: 18px; font-weight: 500; margin-top: 4px;">${month2}</div>
                        </div>
                        <div>
                            <div style="font-size: 12px; color: var(--md-sys-color-on-surface-variant);">比較対象</div>
                            <div style="font-size: 18px; font-weight: 500; margin-top: 4px;">${results.length}名</div>
                        </div>
                    </div>
                </div>

                <div style="overflow-x: auto;">
                    <table style="width: 100%;">
                        <thead>
                            <tr>
                                <th>順位</th>
                                <th>プレイヤー名</th>
                                <th>${month1}<br>ダメージ</th>
                                <th>${month2}<br>ダメージ</th>
                                <th>増加量</th>
                                <th>成長率</th>
                                <th>SLv変化</th>
                            </tr>
                        </thead>
                        <tbody>
            `;

            results.forEach((result, index) => {
                const growthColor = result.damageDiff > 0 ? 'var(--md-sys-color-tertiary)' : 'var(--md-sys-color-error)';
                html += `
                    <tr>
                        <td style="text-align: center;">${index + 1}</td>
                        <td style="font-weight: 500;">${result.name}</td>
                        <td style="text-align: right;">${result.damage1.toLocaleString()}</td>
                        <td style="text-align: right;">${result.damage2.toLocaleString()}</td>
                        <td style="text-align: right; color: ${growthColor}; font-weight: 500;">
                            ${result.damageDiff > 0 ? '+' : ''}${result.damageDiff.toLocaleString()}
                        </td>
                        <td style="text-align: right; color: ${growthColor}; font-weight: 500;">
                            ${result.damageGrowthRate > 0 ? '+' : ''}${result.damageGrowthRate}%
                        </td>
                        <td style="text-align: center;">
                            ${result.slv1} → ${result.slv2}
                            <span style="color: ${result.slvDiff >= 0 ? 'var(--md-sys-color-tertiary)' : 'var(--md-sys-color-error)'};">
                                (${result.slvDiff >= 0 ? '+' : ''}${result.slvDiff})
                            </span>
                        </td>
                    </tr>
                `;
            });

            html += `
                        </tbody>
                    </table>
                </div>
            `;

            container.innerHTML = html;
            document.getElementById('compareResults').style.display = 'block';
        }

    </script>
</body>
</html>